declare module 'tabris-decorators/internals/utils' {
	export type BaseConstructor<T> = Function & {
	    prototype: T;
	};
	export type Constructor<T> = new (...args: any[]) => T;
	export type ParameterDecoratorFactory = (target: Constructor<any>, property: string, index: number) => void;
	export type ClassDecoratorFactory<T> = (type: Constructor<T>) => void;
	export type CustomPropertiesInfo<T extends object> = {
	    [prop in keyof T]?: PropInfo;
	};
	export interface ParamInfo {
	    type: Constructor<any>;
	    injectParam?: string;
	    inject?: boolean;
	}
	export interface PropInfo {
	    inject: boolean;
	}
	export type Decorator<T> = (target: T, property?: string, index?: number) => T | void;
	/**
	 * Takes a callback a decorator function and when possible calls it with the appropriate arguments,
	 * or returns it so it can be can be called later. Rethrows exceptions by the function with an
	 * appropriate error message.
	 */
	export function applyDecorator<T>(name: string, args: any[], decorator: Decorator<T>): any;
	/**
	 * Determines whether a decorator was applied with arguments (dynamic, e.g. "@foo(1,2,2)")
	 * or without (static, e.g. "@foo").
	 */
	export function areStaticDecoratorArgs(args: any[]): boolean;
	/**
	 * Determines whether a class decorator was applied with arguments (dynamic, e.g. "@foo(1,2,2)")
	 * or without (static, e.g. "@foo").
	 */
	export function areStaticClassDecoratorArgs(args: any[]): boolean;
	/**
	 * Defines the a getter on the given prototype. If the prototype already has a getter or setter of that name the
	 * function throws.
	 */
	export function defineGetter(proto: any, property: string, get: () => any): void;
	/**
	 * Gets the type (constructor) of the property as emitted by tsc.
	 * Returns the Object constructor if the type can not be represented
	 * by tsc properly at runtime, OR if the compiler option
	 * emitDecoratorMetadata is not enabled.
	 */
	export function getPropertyType(proto: any, property: string): Constructor<any>;
	/**
	 * Returns true if type information was emitted by tsc for this property.
	 */
	export function hasPropertyType(proto: any, property: string): boolean;
	/**
	 * Gets the type of the parameter. If the type can not be represented properly at runtime this throw an error.
	 */
	export function getParameterType(fn: any, index: number): Constructor<any>;
	/**
	 * Gets array of injection data for each parameter of the given function
	 * If none exists it will be created
	 */
	export function getOwnParamInfo(fn: any): ParamInfo[];
	/**
	 * Gets array of injection data for each parameter of the given function
	 * If none exist and the function is a constructor, the super constructor will checked.
	 * If none exists in the entire chain, null will be returned.
	 */
	export function getParamInfo(fn: any): ParamInfo[] | null;
	export function getCustomProperties<T extends object>(target: T): CustomPropertiesInfo<T>;
	export function getPropertyInfo<T extends object>(target: T, prop: keyof T): PropInfo;
	export function hasInjections(fn: any): boolean;
	export function isPrimitiveType(type: BaseConstructor<any>): boolean;

}
declare module 'tabris-decorators/internals/utils-databinding' {
	import { Composite, Selector, Widget, WidgetCollection } from 'tabris';
	import { BaseConstructor, Constructor } from 'tabris-decorators/internals/utils'; const wasAppendedKey: unique symbol;
	export const originalAppendKey: unique symbol;
	export type Direction = '<<' | '>>' | '';
	export type WidgetInterface = {
	    [prop: string]: any;
	    [originalAppendKey]: typeof Composite.prototype.append;
	    [wasAppendedKey]: boolean;
	} & Widget & WidgetProtected & EventTarget;
	export type TypeGuard<T = any> = (v: T) => boolean;
	export type UserType<T> = Constructor<T>;
	export interface WidgetProtected {
	    _find(selector?: Selector): WidgetCollection<Widget>;
	    _find<U extends Widget>(constructor: new (...args: any[]) => U): WidgetCollection<U>;
	}
	export interface ParamInfo {
	    type: Constructor<any>;
	    injectParam?: string;
	    inject?: boolean;
	}
	export type PostAppendHandler = (widgetInstance: WidgetInterface) => void;
	export type TargetPath = [Direction, string, string];
	/**
	 * Gets list of functions to be executed after first time append is called on instances of the given
	 * widget prototype or instance.
	 */
	export function postAppendHandlers(widget: WidgetInterface): PostAppendHandler[];
	/**
	 * Gets map for the purpose of storing property values of the given instance.
	 */
	export function getPropertyStore(instance: any): Map<string | symbol, any>;
	export function checkPropertyExists(targetWidget: any, targetProperty: string, targetName?: string): void;
	export function trigger(target: Partial<EventTarget>, type: string, eventData: any): void;
	export function markAsAppended(widget: WidgetInterface): void;
	export function isAppended(widget: WidgetInterface): boolean;
	export function checkAppended(widget: WidgetInterface): void;
	export function parseTargetPath(targetPath: string): TargetPath;
	export function checkPathSyntax(targetPath: string): void;
	export function markAsComponent(type: BaseConstructor<Widget>): void;
	export function checkIsComponent(widget: Widget): void;
	export function getTarget(base: WidgetInterface, selector: string): WidgetInterface;
	export {};

}
declare module 'tabris-decorators/api/checkType' {
	import { BaseConstructor } from 'tabris-decorators/internals/utils';
	/**
	 * Performs type checks on the given value. If the check fails the function throws an error message stating the reason.
	 *
	 * The following rules apply:
	 * * Object constructor passes any value
	 * * Object values may be an instance of the given class or any class extending it.
	 * * Primitive types are represented by their boxed type, e.g. a number is `Number`.
	 * * Null and undefined pass unless 'strict' is true
	 * * Boxed values never pass.
	 */
	export function checkType(value: any, type: BaseConstructor<any>, strict?: boolean): void;
	export function isType(value: any, type: BaseConstructor<any>, strict?: boolean): boolean;
	export function getValueString(value: any): string;
	export function getTypeName(type: BaseConstructor<any>): string;

}
declare module 'tabris-decorators/api/convert' {
	export function convert(value: unknown, type: Function): any;

}
declare module 'tabris-decorators/api/equals' {
	export type CompareFn = (valueA: unknown, valueB: unknown) => boolean;
	export type CompareMode = 'strict' | 'shallow' | 'auto' | CompareFn;
	export type ValuePair<T = unknown> = [T, T];
	export type CustomEquals = {
	    equals(value: any): boolean;
	};
	/**
	 * Returns true if the two given values are equal.
	 */
	export function equals(values: ValuePair, mode: CompareMode): boolean;

}
declare module 'tabris-decorators/decorators/property' {
	import { CompareMode } from 'tabris-decorators/api/equals';
	import { CustomPropertyDescriptor } from 'tabris-decorators/internals/CustomPropertyDescriptor';
	import { TypeGuard, UserType } from 'tabris-decorators/internals/utils-databinding';
	export type CustomPropertyDecorator<T> = <Name extends keyof Target, Target extends {
	    [key in Name]: T | unknown;
	}>(target: Target, property: Name) => void;
	export type Converter<T> = 'off' | 'auto' | ((value: unknown) => T);
	export type PropertyDecoratorConfig<T> = TypeGuard<T> | UserType<T> | PropertySuperConfig<T>;
	export type PropertyInitializer<Proto extends object, TargetType> = (instance: Proto, descriptor: CustomPropertyDescriptor<Proto, TargetType>) => Proto;
	export type PropertySuperConfig<T> = {
	    typeGuard?: TypeGuard<T>;
	    type?: UserType<T>;
	    convert?: Converter<T>;
	    equals?: CompareMode;
	    nullable?: boolean;
	    default?: T;
	};
	/**
	 * This decorator makes an instance property fire change events, thereby making it bindable.
	 *
	 * `@property` can be used on any class. A matching change event may (optionally)
	 * be declared explicitly to be able to attach listeners. Example:
	 *
	 * ```ts
	 * ‍@property myText: string;
	 * ‍@event readonly onMyTextChanged: ChangeListeners<string>;
	 * ```
	 *
	 * *Notes:*
	 * * *In TypeScript files `@property` will perform implicit value checks for most types.*
	 * * *In JavaScript files `@property({type: Type})` can be used to enable the same
	 *   kind of value checks.*
	 * * *Use `@property(typeGuard)` or `@property({typeGuard: typeGuard})`
	 *   to perform explicit value checks in either TypeScript or JavaScript.*
	 * * *Use `@property({default: value})` to define the property default value.
	 * * *Use `@property({nullable: false})` to disallow `null` and `undefined`values.
	 * * *Use `@property({equals: 'auto'})` to relax equality check for objects.
	 * * *Use `@property({convert: 'auto'})` to automatically convert the value to the property's type.
	 */
	export function property(targetProto: object, propertyName: string | symbol): void;
	/**
	 * This decorator makes an instance property fire change events, thereby making it bindable.
	 *
	 * `@property` can be used on any class. A matching change event may (optionally)
	 * be declared explicitly to be able to attach listeners. Example:
	 *
	 * ```ts
	 * ‍@property myText: string;
	 * ‍@event readonly onMyTextChanged: ChangeListeners<string>;
	 * ```
	 *
	 * *Notes:*
	 * * *In TypeScript files `@property` will perform implicit value checks for most types.*
	 * * *In JavaScript files `@property({type: Type})` can be used to enable the same
	 *   kind of value checks.*
	 * * *Use `@property(typeGuard)` or `@property({typeGuard: typeGuard})`
	 *   to perform explicit value checks in either TypeScript or JavaScript.*
	 * * *Use `@property({default: value})` to define the property default value.
	 * * *Use `@property({nullable: false})` to disallow `null` and `undefined`values.
	 * * *Use `@property({equals: 'auto'})` to relax equality check for objects.
	 * * *Use `@property({convert: 'auto'})` to automatically convert the value to the property's type.
	 */
	export function property<T>(check: PropertyDecoratorConfig<T>): CustomPropertyDecorator<T>;

}
declare module 'tabris-decorators/internals/CustomPropertyDescriptor' {
	import { PropertySuperConfig, PropertyInitializer } from 'tabris-decorators/decorators/property';
	export type CustomPropertyConfig<T> = PropertySuperConfig<T> & {
	    initializer?: PropertyInitializer<any, T>;
	    readonly?: boolean;
	};
	export const autoDefault: unique symbol;
	export class CustomPropertyDescriptor<Proto extends object, TargetType> {
	    private readonly proto;
	    private readonly propertyName;
	    private static readonly metaDataKey;
	    static get<CandidateProto extends object, ExpectedTargetType>(proto: CandidateProto, propertyName: keyof CandidateProto & string): CustomPropertyDescriptor<CandidateProto, ExpectedTargetType>;
	    static isUnchecked<PropertyName extends string>(target: object, propertyName: PropertyName): boolean;
	    static has<PropertyName extends string>(target: any, propertyName: PropertyName): target is {
	        [name in PropertyName]: any;
	    };
	    readonly enumerable = true;
	    readonly configurable = true;
	    readonly get: () => TargetType;
	    readonly set: (value: TargetType) => void;
	    private userType;
	    private typeGuard;
	    private readonly targetType;
	    private readonly changeEvent;
	    private equals;
	    private convert;
	    private youHaveBeenWarned;
	    private defaultValue;
	    private nullable;
	    private readonly;
	    private initializer;
	    constructor(proto: Proto, propertyName: keyof Proto & string);
	    addConfig(config: CustomPropertyConfig<TargetType>): void;
	    private setValue;
	    private getValue;
	    private isUnchecked;
	    private checkType;
	    private setUserType;
	    private addTypeGuard;
	    private setCompareMode;
	    private setInitializer;
	    private setConverter;
	    private setNullable;
	    private setReadonly;
	    private setDefaultValue;
	    private getType;
	    private isConvertible;
	    private handleTypeMissing;
	}

}
declare module 'tabris-decorators/decorators/inject' {
	import 'reflect-metadata';
	import { Injector } from 'tabris-decorators/api/Injector';
	import { Decorator } from 'tabris-decorators/internals/utils';
	export type InjectDecorator = typeof unboundInject;
	export function bindDecoratorInject(injector: Injector): typeof unboundInject;
	/**
	 * A decorator that marks a constructor parameter for injections based on the type of the parameter:
	 * ```
	 * constructor(@inject a: ClassA) { ... }
	 * ```
	 * A parameter can be passed to the injector (see `@injectable` and `@injectionHandler`) like this:
	 * ```
	 * constructor(@inject('some value') a: ClassA) { ... }
	 * ```
	 */
	export function unboundInject(param: string): Decorator<any>;
	export function unboundInject(target: object, property: string, index?: number): void;

}
declare module 'tabris-decorators/decorators/injectable' {
	import 'reflect-metadata';
	import { InjectionParameter, Injector } from 'tabris-decorators/api/Injector';
	import { BaseConstructor, ClassDecoratorFactory, Constructor } from 'tabris-decorators/internals/utils';
	export type InjectableDecorator = typeof unboundInjectable;
	export function bindDecoratorInjectable(injector: Injector): typeof unboundInjectable;
	/**
	 * A decorator that makes a class injectable via `@inject` or `resolve(type)`.
	 * It can be injected as itself or as any of its super-classes:
	 *
	 * ```
	 * ‍@injectable class Foo2 extends Foo { ... }
	 * ```
	 * A configuration object can be passed:
	 * ```
	 * ‍@injectable({opt: value})
	 * class Foo2 extends Foo { ... }
	 * ```
	 * The object can have any of these entries:
	 * - `shared: boolean`: when `true`this makes the class effectively a singleton
	 * - `implements: OtherClass`: allows the class to be injected as `OtherClass`
	 * - `priority: number`: The priority of this class relative to other compatible injectables. Defaults to 0.
	 * - `param: value`: allows injection only when `@inject(param)` gives the exact same parameter value.
	 */
	export function unboundInjectable<T>(config: InjectableConfig<T>): ClassDecoratorFactory<T>;
	export function unboundInjectable<T>(type: Constructor<T>): void;
	export interface InjectableConfig<T> {
	    shared?: boolean;
	    priority?: number;
	    implements?: BaseConstructor<T>;
	    param?: InjectionParameter;
	}
	export const injectableKey: unique symbol;

}
declare module 'tabris-decorators/decorators/injectionHandler' {
	import { Injection, Injector } from 'tabris-decorators/api/Injector';
	import { BaseConstructor } from 'tabris-decorators/internals/utils';
	export type IHFunction<T> = (injection: Injection) => T | void;
	export type IHDescriptor<T> = TypedPropertyDescriptor<IHFunction<T>>;
	export type CoreInjectionHandlerDecorator<T> = (target: BaseConstructor<any>, propertyName: string, descriptor: IHDescriptor<T>) => void;
	export type InjectionHandlerDecorator = typeof unboundInjectionHandler;
	export function bindDecoratorInjectionHandler(injector: Injector): typeof unboundInjectionHandler;
	/**
	 * Registers a static method to handle injections for the given type:
	 * ```
	 * ‍@injectionHandler(MyServiceClass)
	 * static createMyServiceClass(injection: Injection) {
	 *   return new MyServiceClass(someArg);
	 * }
	 * ```
	 * A priority may also be given, defaults to 0:
	 * ```ts
	 * @injectionHandler({targetType: MyServiceClass, priority: 2})
	 * ```
	 *
	 * The decorated method must return a value compatible to the given type or `null`/`undefined`.
	 * The method is passed an `Injection` object with the following fields:
	 * - `type`: The exact type that was requested.
	 * - `injector`: The `Injector` instance the injection handler is registered with.
	 * - `param`: An injection parameter that may have been passed via `@inject(param)` or `resolve(type, param)`
	 */
	export function unboundInjectionHandler<T>(targetType: BaseConstructor<T>): CoreInjectionHandlerDecorator<T>;
	export function unboundInjectionHandler<T>(param: {
	    targetType: BaseConstructor<T>;
	    priority?: number;
	}): CoreInjectionHandlerDecorator<T>;

}
declare module 'tabris-decorators/decorators/shared' {
	import { Injector } from 'tabris-decorators/api/Injector';
	import { Constructor } from 'tabris-decorators/internals/utils';
	export type SharedDecorator = typeof unboundShared;
	export function bindDecoratorShared(injector: Injector): typeof unboundShared;
	export function unboundShared(type: Constructor<any>): void;

}
declare module 'tabris-decorators/api/to' {
	export interface Binding {
	    path: string;
	    converter?: (val: any) => any;
	}
	/**
	 * Allows assigning a converter function to a one way binding:
	 *
	 *    <textView
	 *       bind-text={to('person.dob', v => v.toLocaleString())} />
	 *
	 * This is the same as:
	 *
	 *    <textView
	 *       bind-text={{path: 'person.dob', converter: v => v.toLocaleString())} />
	 *
	 *  Can also be used to create reuseable shorthands:
	 *
	 *     const toLocaleString
	 *       = (path: string) => to(path, v => v.toLocaleString());
	 *
	 *     <textView bind-text={toLocaleString('person.dob')} />
	 */
	export function to(path: string, converter: (val: any) => any): Binding;

}
declare module 'tabris-decorators/internals/applyJsxBindings' {
	import 'reflect-metadata';
	import { Widget } from 'tabris';
	import { Severity } from 'tabris-decorators/internals/ExtendedJSX';
	export interface JsxBindings {
	    [targetProperty: string]: string;
	}
	export function applyJsxBindings(targetInstance: Widget, bindings: JsxBindings, safety: Severity): void;
	export function getOneWayBindings(instance: Widget): OneWayBinding[];
	export function clearOneWayBindings(instance: Widget): void;
	export interface OneWayBinding {
	    type: 'bind' | 'template';
	    converter: (v: any) => string;
	    bindingString: string;
	    target: Widget;
	    targetProperty: string;
	    path: string[];
	    fallbackValue: any;
	}

}
declare module 'tabris-decorators/internals/ExtendedJSX' {
	import { JsxProcessor, NativeObject } from 'tabris';
	import { Injector } from 'tabris-decorators/api/Injector';
	export interface Properties {
	    [property: string]: any;
	}
	export type JsxConstructor = {
	    prototype: JSX.ElementClass;
	    new (): object;
	};
	export type JsxNativeType = {
	    prototype: JSX.ElementClass;
	    new (): NativeObject;
	};
	export type JsxInfo = {
	    source: unknown;
	} | {
	    processor: ExtendedJSX;
	    componentType: JsxConstructor;
	    sfc: ((param: object) => any);
	    attributes: object;
	    children: JsxInfo[];
	};
	export function getJsxInfo(source: any): JsxInfo;
	export function setInjectorOverride(target: JsxConstructor, injector: Injector): void;
	export type Severity = 'warn' | 'error';
	export class ExtendedJSX extends JsxProcessor {
	    private readonly injector;
	    unsafeBindings: Severity;
	    constructor(injector: Injector);
	    createCustomComponent(type: JsxConstructor, attributes: any): JSX.ElementClass | string;
	    createFunctionalComponent(type: ((param: object) => any), attributes: any): JSX.ElementClass | string;
	    createNativeObject(Type: JsxNativeType, attributes: Properties): NativeObject;
	    private extractBindings;
	    private convertType;
	}

}
declare module 'tabris-decorators/api/Injector' {
	import { InjectDecorator } from 'tabris-decorators/decorators/inject';
	import { InjectableDecorator } from 'tabris-decorators/decorators/injectable';
	import { InjectionHandlerDecorator } from 'tabris-decorators/decorators/injectionHandler';
	import { SharedDecorator } from 'tabris-decorators/decorators/shared';
	import { ExtendedJSX } from 'tabris-decorators/internals/ExtendedJSX';
	import { BaseConstructor } from 'tabris-decorators/internals/utils';
	export type InjectionParameter = object | string | number | boolean | null;
	export type CreateFunction = typeof Injector.prototype.create;
	export type ResolveFunction = typeof Injector.prototype.resolve;
	export type RegisterFunction = typeof Injector.prototype.register;
	export interface HandlerRegistration<Type, Result extends Type> {
	    targetType: BaseConstructor<Type>;
	    handler: InjectionHandlerFunction<Result>;
	    priority?: number;
	}
	export interface Injection {
	    type: BaseConstructor<any>;
	    param: InjectionParameter;
	    injector: Injector;
	}
	export type InjectionHandlerFunction<T> = (injection: Injection) => T | null | undefined;
	/**
	 * An `Injector` instance manages injection handlers and fulfills injections.
	 *
	 * You may create your own instance of `Injector` if you wish to keep your injection
	 * handlers separate from those kept in the global `injector` object exported
	 * by `tabris-decorators`. You must then use the attached decorators and `JSX` object
	 * instead of the global ones.
	 */
	export class Injector {
	    /**
	     * Returns the instance of Injector that was used to create the given object.
	     * Given a class decorated with @inject or @shared it returns the injector
	     * associated with these.
	     */
	    static get(object: object, fallback?: Injector): Injector;
	    readonly injectionHandler: InjectionHandlerDecorator;
	    readonly inject: InjectDecorator;
	    readonly injectable: InjectableDecorator;
	    readonly shared: SharedDecorator;
	    /**
	     * This object needs to be present in the module namespace to allow JSX expressions that
	     * use this `Injector` instance to fulfill injections. E.g.
	     * ```
	     *   const JSX = injector.jsxProcessor; // shadows global JSX object
	     * ```
	     * Or to set it as the default for all JSX elements globally:
	     * ```
	     *   JSX.install(injector.jsxProcessor);
	     * ```
	     */
	    readonly jsxProcessor: ExtendedJSX;
	    private handlers;
	    private injectionStack;
	    private resolveQueue;
	    /**
	     * Registers a value as a shared injectable for the given type.
	     * Equivalent to calling `addHandler(type, () => value)` or using
	     * `@shared`.
	     */
	    register: <T, U extends T>(targetType: BaseConstructor<T>, value: U) => U;
	    /**
	     * Explicitly registers a new injection handler. Same as using the attached `injectionHandler`
	     * decorator.
	     */
	    addHandler: {
	        <T, U extends T>(targetType: BaseConstructor<T>, handler: InjectionHandlerFunction<U>): void;
	        <T, U extends T>(param: HandlerRegistration<T, U>): void;
	    };
	    /**
	     * Returns an instance for an injectable type, just like using the `@inject` decorator
	     * would do in a constructor.
	     */
	    resolve: <T>(type: BaseConstructor<T>, param?: InjectionParameter) => T;
	    /**
	     * `create(type: Class, ...parameters: any[])`
	     *
	     * Creates an instance of the given class and fills in all the constructor parameters decorated with `@inject`.
	     * Parameters given after the type will be passed to the constructor, potentially overriding
	     * the injection value.
	     */
	    create: <T, U, V, W>(type: new (arg1?: U, arg2?: V, arg3?: W, ...remaining: any[]) => T, arg1?: U, arg2?: V, arg3?: W, ...remaining: any[]) => T;
	    private scheduleResolveProperties;
	    private resolvePropertyInjections;
	    private findHandlerRegistrations;
	    private getUnboxer;
	    private passValue;
	    private unboxValue;
	    private forEachPrototype;
	    private tagResult;
	}
	export const injector: Injector;

}
declare module 'tabris-decorators/internals/subscribe' {
	export function subscribe(root: any, path: string[], cb: (value: unknown) => void): () => void;
	export function supportsChangeEvents(target: Partial<EventTarget>, targetProperty: string): boolean;

}
declare module 'tabris-decorators/internals/processOneWayBindings' {
	import 'reflect-metadata';
	import { Widget } from 'tabris';
	import { OneWayBinding } from 'tabris-decorators/internals/applyJsxBindings';
	import { WidgetInterface } from 'tabris-decorators/internals/utils-databinding';
	export function processOneWayBindings(base: WidgetInterface, target: Widget): void;
	export function initOneWayBinding(base: WidgetInterface, binding: OneWayBinding): void;

}
declare module 'tabris-decorators/decorators/component' {
	import 'reflect-metadata';
	import { Composite } from 'tabris';
	import { Injector } from 'tabris-decorators/api/Injector';
	import { Constructor } from 'tabris-decorators/internals/utils'; type ComponentOptions = {
	    injector?: Injector;
	}; type ComponentDecorator = <T extends Constructor<Composite>>(arg: T) => T;
	/**
	 * A decorator for classes extending `Composite` (directly or indirectly),
	 * otherwise known as a "custom component".
	 *
	 * Encapsules instances of the decorated class and enables data binding features.
	 *
	 * Example for a one-way binding between property `myText` of the decorated
	 * class and property `text` of a child element:
	 *
	 * ```jsx
	 * this.append(
	 *  <TextView bind-text='myText'/>
	 * );
	 * ```
	 *
	 * *Notes:*
	 * * *This works on all children (direct or indirect) of the component.
	 * * *Consult the developer guide article on `@component` for further details of one-way bindings.*
	 * * *Due to the encapsulation feature children of the component are only accessible
	 *    using either `@getById` or the protected `_children`, `_find` and `_apply` methods.*
	 * * *For creating two-way bindings use `@bind` and `@bindAll`.*
	 */
	export function component<T extends Constructor<Composite>>(arg: T): T;
	export function component(options: ComponentOptions): ComponentDecorator;
	export {};

}
declare module 'tabris-decorators/api/StateProvider' {
	import { Action as GenericAction, DefaultActions, DefaultRootState } from 'tabris-decorators';
	import { Widget } from 'tabris';
	import { ActionMapper } from 'tabris-decorators/api/ActionMapper';
	export type MappedRules = {
	    [selector: string]: {
	        [props: string]: any;
	    };
	};
	export type StateMapper<MappedState, RootState = DefaultRootState> = (state: RootState) => MappedState & {
	    apply?: MappedRules;
	};
	export interface Action<T = any> {
	    type: T;
	}
	export type AnyAction = DefaultActions[keyof DefaultActions] | {
	    type: typeof NO_ACTION;
	};
	export type Dispatch<A> = (action: A) => A;
	export type HookOptions<Target extends Widget, RootState extends object, ProviderAction extends GenericAction> = {
	    stateProvider: StateProvider<RootState, ProviderAction>;
	    target: Target;
	    stateMapper?: StateMapper<Partial<Target>, RootState>;
	    actionMapper?: ActionMapper<Target, ProviderAction>;
	};
	export const NO_ACTION: unique symbol;
	export class StateProvider<State = DefaultRootState, ProviderAction extends GenericAction = AnyAction> {
	    static hook<Target extends Widget, RootState extends object, HookedProviderAction extends GenericAction>(options: HookOptions<Target, RootState, HookedProviderAction>): void;
	    constructor(original: Partial<StateProvider<State, ProviderAction>>);
	    getState(): State;
	    subscribe(cb: () => void): void;
	    dispatch: Dispatch<ProviderAction>;
	}

}
declare module 'tabris-decorators/api/ActionMapper' {
	import { Action as GenericAction, Dispatch } from 'tabris-decorators';
	import { EventOfListeners, Listeners, UnpackListeners } from 'tabris';
	import { MappedRules } from 'tabris-decorators/api/StateProvider';
	export type ActionMapper<Target extends {}, Action extends GenericAction> = ActionMapperFunction<Target, Action> | ActionMapperObject<Target, Action>;
	export type ActionMapperFunction<Target extends {}, Action extends GenericAction> = (dispatch: Dispatch<Action>) => Callbacks<Target>;
	export type ActionMapperObject<Target extends {}, Action extends GenericAction> = {
	    [Key in CallbackKeysOf<Target>]?: ActionCreator<Target[Key], Action>;
	} & {
	    apply?: MappedRules;
	};
	export type Callback = (...args: any[]) => any;
	export type Callbacks<T extends object> = {
	    [Key in CallbackKeysOf<T>]?: UnpackListeners<T[Key]>;
	} & {
	    apply?: MappedRules;
	}; type ActionCreator<TargetFunction extends (...args: any[]) => any, Action> = TargetFunction extends Listeners<any> ? (ev: EventOfListeners<TargetFunction>) => Action : (...args: Parameters<TargetFunction>) => Action; type FunctionKeysOf<T> = {
	    [K in keyof T]: T[K] extends Function ? K : never;
	}[keyof T]; type Forbidden = 'append' | 'children' | 'find' | 'apply' | 'appendTo' | 'insertBefore' | 'insertAfter' | 'detach' | 'siblings' | 'animate' | 'dispose' | 'toString' | 'constructor' | 'bounds' | 'absoluteBounds'; type CallbackKeysOf<T> = FunctionKeysOf<Omit<T, Forbidden | number | symbol>>;
	export {};

}
declare module 'tabris-decorators/decorators/connect' {
	import { Action as GenericAction, AnyAction, DefaultRootState } from 'tabris-decorators';
	import 'reflect-metadata';
	import { Properties, Widget } from 'tabris';
	import { ActionMapper, ActionMapperFunction } from 'tabris-decorators/api/ActionMapper';
	import { StateMapper } from 'tabris-decorators/api/StateProvider';
	import { Constructor } from 'tabris-decorators/internals/utils';
	export type Connectable<T, U = T & Widget> = Constructor<U> | ((attributes?: any) => U);
	export type StateToProps<T> = StateMapper<tabris.Properties<T>>;
	export type DispatchToProps<T> = ActionMapperFunction<T, AnyAction>;
	export function connect<Mapped extends {}, RootState = DefaultRootState, Action extends GenericAction = AnyAction>(mapState: StateMapper<Mapped extends Widget ? Properties<Mapped> : Partial<Mapped>, RootState> | null, mapDispatchToProps?: ActionMapper<Mapped extends Widget ? Mapped : object, Action>): <T extends Connectable<Mapped>>(target: T) => T;

}
declare module 'tabris-decorators/decorators/prop' {
	import { CustomPropertyDecorator, PropertyDecoratorConfig } from 'tabris-decorators/decorators/property';
	/**
	 * This decorator makes an instance property fire change events, thereby making it bindable.
	 *
	 * `@prop` can be used on any class. A matching change event may (optionally)
	 * be declared explicitly to be able to attach listeners. Example:
	 *
	 * ```ts
	 * ‍@prop myText: string;
	 * ‍@event readonly onMyTextChanged: ChangeListeners<string>;
	 * ```
	 *
	 * *Notes:*
	 * * *In TypeScript files `@prop` will perform implicit value checks for most types.*
	 * * *In JavaScript files `@prop({type: Type})` or `@prop(Type)` can be used to enable the same
	 *   kind of value checks.*
	 * * *`@prop(config)` supports all the same options as `@property(config)`, but uses different defaults.*
	 */
	export function prop(targetProto: object, propertyName: string | symbol): void;
	/**
	 * This decorator makes an instance property fire change events, thereby making it bindable.
	 *
	 * `@prop` can be used on any class. A matching change event may (optionally)
	 * be declared explicitly to be able to attach listeners. Example:
	 *
	 * ```ts
	 * ‍@prop myText: string;
	 * ‍@event readonly onMyTextChanged: ChangeListeners<string>;
	 * ```
	 *
	 * *Notes:*
	 * * *In TypeScript files `@prop` will perform implicit value checks for most types.*
	 * * *In JavaScript files `@prop({type: Type})` or `@prop(Type)` can be used to enable the same
	 *   kind of value checks.*
	 * * *`@prop(config)` supports all the same options as `@property(config)`, but uses different defaults.*
	 */
	export function prop<T>(check: PropertyDecoratorConfig<T>): CustomPropertyDecorator<T>;

}
declare module 'tabris-decorators/internals/TwoWayBinding' {
	import { TargetPath, WidgetInterface } from 'tabris-decorators/internals/utils-databinding';
	import { BindSuperConfig } from 'tabris-decorators/decorators/bind'; type LocalPath = [string, string?];
	export class TwoWayBinding {
	    private readonly component;
	    private readonly localPath;
	    private readonly targetPath;
	    static create(component: WidgetInterface, config: BindSuperConfig<unknown>): void;
	    private target;
	    private targetProperty;
	    private direction;
	    private suspended;
	    private fallback;
	    private cancelLocal;
	    private cancelTarget;
	    constructor(component: WidgetInterface, localPath: LocalPath, targetPath: TargetPath);
	    toString(): string;
	    private init;
	    private dispose;
	    private subscribeToLocalValue;
	    private subscribeToTargetValue;
	    private subscribe;
	    private setSourceProperty;
	    private getSourceValue;
	    private hasValidSource;
	    private setTargetProperty;
	    private checkPropertySafety;
	    private tryTo;
	}
	export {};

}
declare module 'tabris-decorators/decorators/bind' {
	import { Composite } from 'tabris';
	import { CustomPropertyDecorator, PropertySuperConfig } from 'tabris-decorators/decorators/property';
	import { TargetPath, WidgetInterface } from 'tabris-decorators/internals/utils-databinding';
	export type BindAllConfig<T> = PropertySuperConfig<T> & {
	    all: {
	        [Property in keyof T]?: string;
	    };
	};
	export type BindSingleConfig<T> = PropertySuperConfig<T> & {
	    path: string;
	};
	export type BindSuperConfig<T> = PropertySuperConfig<T> & {
	    componentProto: WidgetInterface;
	    componentProperty: string;
	    targetPath: TargetPath | null;
	    all: TwoWayBindingPaths | null;
	};
	export type TwoWayBindingPaths = {
	    [sourceProperty: string]: TargetPath;
	};
	export type BindAllDecorator<ValidKeys extends string> = <PropertyName extends string, Target extends {
	    [P in PropertyName]: {
	        [SubProperty in ValidKeys]: any;
	    };
	} & Composite>(target: Target, property: PropertyName) => void;
	/**
	 * A decorator for instance properties of classes extending `Composite`, i.e. a custom component.
	 * It creates a two-way binding between the decorated property and a child (direct or indirect)
	 * of the component. Example:
	 *
	 * ```ts
	 * ‍@bind('#childId.text')
	 * myProp: string = 'foo';
	 * ```
	 *
	 * *Notes:*
	 * * *`@bind` behaves like `@property` in most regards.*
	 * * *Like `@property` it also supports the `typeGuard` and `type` options.*
	 * * *Use`@bind({all: bindings})` or `@bindAll(bindings)` to create bindings to a model.*
	 * * *`@bind(path)` is the same as `@bind({path: path})`.*
	 * * *In addition to id selectors, type selectors and `:host` are also supported.*
	 */
	export function bind<T>(config: BindSingleConfig<T> | string): CustomPropertyDecorator<T>;
	/**
	 * A decorator for instance properties of classes extending `Composite`, i.e. a custom component.
	 * It creates a two-way binding between properties of a model (e.g. an object using `@property`)
	 * and children (direct or indirect) of the component. Example:
	 *
	 * ```ts
	 * ‍@bind(all: {
	 *  modelPropA: '#childId1.text'
	 *  modelPropB: '#childId2.selection'
	 * }})
	 * myProp: MyModel;
	 * ```
	 *
	 * *Notes:*
	 * * *`@bind` behaves like `@property` and supports all the same configuration options.*
	 * * *Use`@bind(path)` or `@bind({path: path})` to create bindings to the component property itself.*
	 * * *`@bindAll(bindings)` can be used as a shorthand for `@bind({all: bindings})`.*
	 * * *In addition to id selectors, type selectors and `:host` are also supported.*
	 */
	export function bind<T extends object>(config: BindAllConfig<T>): CustomPropertyDecorator<T>;

}
declare module 'tabris-decorators/decorators/bindAll' {
	import { CustomPropertyDecorator } from 'tabris-decorators/decorators/property';
	/**
	 * A decorator for instance properties of classes extending `Composite`, i.e. a custom component.
	 * It creates a two-way binding between properties of a model (e.g. an object using `@property`)
	 * and children (descendants) of the component. Example:
	 *
	 *  ```ts
	 * ‍@bindAll({
	 *  modelPropA: '#childId1.text'
	 *  modelPropB: '#childId2.selection'
	 * })
	 * myProp: MyModel;
	 *
	 * ```
	 * *Notes:*
	 * * *`@bindAll` behaves like `@property` in most regards.*
	 * * *`@bindAll(bindings)` is a shorthand for `@bind({all: bindings})`. The latter
	 * also supports the `typeGuard` and `type` options.*
	 * * *In addition to id selectors, type selectors and `:host` are also supported.* *
	 * * *Use`@bind(path)` or `@bind({path: path})` to create bindings to the property itself.*
	 */
	export function bindAll<T>(bindings: {
	    [Property in keyof T]?: string;
	}): CustomPropertyDecorator<T>;

}
declare module 'tabris-decorators/decorators/getById' {
	import 'reflect-metadata';
	import { Composite } from 'tabris';
	import { TypeGuard } from 'tabris-decorators/internals/utils-databinding';
	/**
	 * A decorator for instance properties of classes extending `Composite`,
	 * otherwise known as a "custom component".
	 *
	 * Makes the decorated property return a component-internal child element
	 * whose id is identical to the property name. This provides an alternative to
	 * the `_find` function. Example:
	 *
	 * ```ts
	 * ‍@getById readonly button1: Button;
	 * ```
	 * *
	 * *Notes:*
	 * * *The property will be read-only.*
	 * * *If there is no child with the correct id, or more than one, an error will be thrown.*
	 * * *In TypeScript the type of the widget will also be checked.*
	 * * *Use `@getById(typeGuard)` to implement an explicit type check instead. This is
	 *   especially useful in JavaScript where the is no implicit type check.*
	 */
	export function getById(targetProto: Composite, property: string): void;
	/**
	 * A decorator for instance properties of classes extending `Composite`,
	 * otherwise known as a "custom component".
	 *
	 * Makes the decorated property return a component-internal child element
	 * whose id is identical to the property name and passes the type guard check.
	 * This is especially useful in JavaScript where the is no implicit type check.
	 * JavaScript example:
	 *
	 * ```ts
	 * /⋆⋆ @type {Button} ⋆/
	 * ‍@getById(widget => widget instanceof Button)
	 * readonly buttonId;
	 * ```
	 *
	 * *Notes:*
	 * * *The property will be read-only.*
	 * * *If there is no child with the correct id, or more than one, an error will be thrown.*
	 * * *In TypeScript this feature may be used to override the explicit type check.
	 * * *Use `@getById` if no type check is needed/desired.
	 */
	export function getById(check: TypeGuard): PropertyDecorator;

}
declare module 'tabris-decorators/decorators/event' {
	/**
	 * A decorator that can be attached to a property of the type `Listeners`.
	 *
	 * The name of the property must start with "on", e.g. "onMyEvent".
	 * The property will become read-only and contain a `Listeners` instance
	 * that is configured to dispatch events on the object it is attached to.
	 *
	 * When used on a widget the `Listeners` instance will be integrated in
	 * the existing event system. Events triggered via one API will also be issued via the other.
	 */
	export function event(targetProto: object, evPropertyName: string): void;

}
declare module 'tabris-decorators/api/List' {
	import { Listeners } from 'tabris'; const data: unique symbol; const observers: unique symbol; const init: unique symbol;
	export type ListLike<T> = {
	    length: number;
	    [index: number]: T;
	    [Symbol.iterator](): IterableIterator<T>;
	    entries(): IterableIterator<[number, T]>;
	    find<S extends T>(predicate: (this: void, value: T, index: number, obj: ListLike<T>) => value is S, thisArg?: any): S | undefined;
	    find(predicate: (value: T, index: number, obj: ListLike<T>) => unknown, thisArg?: any): T | undefined;
	    findIndex(predicate: (value: T, index: number, obj: ListLike<T>) => unknown, thisArg?: any): number;
	    forEach(callbackfn: (value: T, index: number, array: ListLike<T>) => void, thisArg?: any): void;
	    indexOf(searchElement: T, fromIndex?: number): number;
	    join(separator?: string): string;
	    keys(): IterableIterator<number>;
	    lastIndexOf(searchElement: T, fromIndex?: number): number;
	    pop(): T | undefined;
	    push(...items: T[]): number;
	    shift(): T | undefined;
	    splice(start: number, deleteCount?: number, ...items: T[]): T[];
	    unshift(...items: T[]): number;
	    values(): IterableIterator<T>;
	};
	export type ListLikeConstructor = {
	    new (arrayLength?: number): (any[] | ListLike<any>);
	    new <T>(...items: T[]): (T[] | ListLike<T>);
	    from<T>(arrayLike: ArrayLike<T> | Iterable<T>): ListLike<T>;
	    from<T, U>(arrayLike: ArrayLike<T>, mapfn?: (v: T, k: number) => U, thisArg?: any): ListLike<U>;
	    of<T>(...items: T[]): ListLike<T>;
	};
	export type Mutation<T> = {
	    start: number;
	    deleteCount: number;
	    items: T[];
	    target: ListLike<T>;
	};
	export function listObservers<T>(list: List<T>): Listeners<Mutation<T>>;
	export class List<T> implements ListLike<T> {
	    static from<In, Out>(arrayLike: ArrayLike<In> | Iterable<In>, mapfn?: (v: In, k: number) => Out, thisArg?: any): List<In>;
	    static of<Item>(...items: Item[]): List<Item>;
	    private [data];
	    private [observers];
	    constructor(arrayLength?: number);
	    constructor(...items: T[]);
	    constructor(initializer: {
	        [init]: any[];
	    });
	    get length(): number;
	    set length(value: number);
	    [Symbol.iterator](): IterableIterator<T>;
	    entries(): IterableIterator<[number, T]>;
	    find<S extends T>(predicate: (this: void, value: T, index: number, obj: List<T>) => value is S, thisArg?: any): S | undefined;
	    findIndex(predicate: (value: T, index: number, obj: List<T>) => unknown, thisArg?: any): number;
	    forEach(callbackfn: (value: T, index: number, array: List<T>) => void, thisArg?: any): void;
	    indexOf(searchElement: T, fromIndex?: number): number;
	    join(separator?: string): string;
	    keys(): IterableIterator<number>;
	    lastIndexOf(searchElement: T, fromIndex?: number): number;
	    pop(): T | undefined;
	    push(...items: T[]): number;
	    shift(): T | undefined;
	    splice(start: number, deleteCount?: number, ...items: T[]): T[];
	    unshift(...items: T[]): number;
	    values(): IterableIterator<T>;
	}
	export interface List<T> {
	    [index: number]: T;
	}
	export {};

}
declare module 'tabris-decorators/internals/ListLikeObserver' {
	import { ListLike, Mutation } from 'tabris-decorators';
	export class ListLikeObserver<T> {
	    private _callback;
	    private _source;
	    constructor(_callback: (ev: Mutation<T>) => void);
	    set source(value: ListLike<T>);
	    get source(): ListLike<T>;
	    protected _autoUpdate(prevSource: ListLike<T>): void;
	}

}
declare module 'tabris-decorators/api/ItemPicker' {
	import { ChangeListeners, EventObject, Factory, JSXAttributes, Listeners, Picker, Properties, PropertyChangedEvent } from 'tabris';
	import { ListLike, Mutation } from 'tabris-decorators/api/List';
	import { Binding } from 'tabris-decorators/api/to';
	export class ItemPickerSelectEvent<ItemType, Target = any> extends EventObject<Target> {
	    readonly item: ItemType;
	    readonly itemIndex: number;
	    readonly itemText: string;
	    constructor(item: ItemType, itemIndex: number, itemText: string);
	}
	export type TextSource<T> = string | Binding | null;
	export type ItemPickerProperties<ItemType> = Properties<Picker> & {
	    items?: ListLike<ItemType>;
	    textSource?: TextSource<ItemType>;
	}; namespace internal {
	    class ItemPicker<ItemType> extends Picker {
	        jsxAttributes: JSXAttributes<this> & tabris.Attributes<Picker> & {
	            children?: ListLike<ItemType> | string;
	        };
	        onItemSelect: Listeners<ItemPickerSelectEvent<ItemType, this>>;
	        onItemsChanged: Listeners<PropertyChangedEvent<this, ListLike<ItemType>>>;
	        onSelectionChanged: Listeners<PropertyChangedEvent<this, ItemType>>;
	        onTextSourceChanged: ChangeListeners<this, 'textSource'>;
	        private _observer;
	        private _textSource;
	        private _texts;
	        private _unsubsribers;
	        private _inRefresh;
	        constructor({ items, textSource, ...properties }?: ItemPickerProperties<ItemType>);
	        set items(value: ListLike<ItemType>);
	        get items(): ListLike<ItemType>;
	        set selection(value: ItemType);
	        get selection(): ItemType;
	        set textSource(value: TextSource<ItemType>);
	        get textSource(): TextSource<ItemType>;
	        protected _handleListMutation: (ev: Mutation<ItemType>) => void;
	        protected _computeTexts(): void;
	        protected _bindItems(binding: Binding): any[];
	        protected _unbindItems(): void;
	        protected _handleSelectionIndexChanged: () => void;
	        protected _handleSelect: ({ index }: {
	            index: number;
	        }) => void;
	        protected _refresh(): void;
	        protected _reorderProperties(properties: string[]): string[];
	        [JSX.jsxFactory](Type: any, attributes: any): ItemPicker<any>;
	    }
	}
	export type ItemPickerConstructor = typeof internal.ItemPicker;
	export interface ItemPickerFactory extends Factory<ItemPickerConstructor>, ItemPickerConstructor {
	}
	export const ItemPicker: ItemPickerFactory;
	export type ItemPicker<ItemType> = internal.ItemPicker<ItemType>;
	export {};

}
declare module 'tabris-decorators/api/interfaces' {
	export { Constructor, BaseConstructor } from 'tabris-decorators/internals/utils';
	export { TypeGuard } from 'tabris-decorators/internals/utils-databinding';

}
declare module 'tabris-decorators/api/Cell' {
	import { ChangeListeners, Composite, Factory, JSXAttributes, JSXChildren, Properties, Widget } from 'tabris';
	import { Constructor } from 'tabris-decorators/internals/utils'; const factory: unique symbol;
	export type ItemTypeDef<T> = Constructor<T> | 'string' | 'number' | 'boolean';
	export type ItemCheck<T> = (value: T) => boolean;
	export type CellCreationArgs<ItemType> = {
	    itemType?: ItemTypeDef<ItemType>;
	    itemCheck?: ItemCheck<ItemType>;
	    item?: never;
	    selectable?: boolean;
	}; namespace internal {
	    class Cell<ItemType = unknown> extends Composite {
	        static factory(original: Cell): () => Cell;
	        jsxAttributes: JSXAttributes<this> & {
	            children?: JSXChildren<Widget>;
	        } & CellCreationArgs<ItemType>;
	        onItemChanged: ChangeListeners<this, 'item'>;
	        onItemIndexChanged: ChangeListeners<this, 'itemIndex'>;
	        readonly selectable: boolean;
	        readonly itemType: ItemTypeDef<ItemType>;
	        readonly itemCheck: ItemCheck<ItemType>;
	        item: ItemType;
	        itemIndex: number;
	        private [factory];
	        constructor(properties?: Properties<Composite> & CellCreationArgs<ItemType>);
	        [JSX.jsxFactory](Type: any, attributes: any): any;
	    }
	    class TextCell extends Cell<any> {
	        constructor();
	    }
	}
	export type CellConstructor = typeof internal.Cell;
	export interface CellFactory extends Factory<CellConstructor>, CellConstructor {
	}
	export type Cell<ItemType = unknown> = internal.Cell<ItemType>;
	export const Cell: CellFactory;
	export const TextCell: import("tabris").CallableConstructor<typeof internal.TextCell, internal.TextCell, (...args: any[]) => internal.TextCell>;
	export type TextCell = internal.TextCell;
	export {};

}
declare module 'tabris-decorators/api/ListView' {
	import { Attributes, ChangeListeners, CollectionView, EventObject, Factory, JSXAttributes, Listeners, Properties, Widget } from 'tabris';
	import { Cell } from 'tabris-decorators/api/Cell';
	import { ListLike, Mutation } from 'tabris-decorators/api/List';
	export enum ItemAction {
	    Primary = 1,
	    Secondary = 2,
	    Toggle = 3,
	    Dismiss = 4
	}
	export class ListViewSelectEvent<ItemType, Target = any> extends EventObject<Target> {
	    readonly item: ItemType;
	    readonly itemIndex: number;
	    readonly originalEvent: EventObject<Widget>;
	    readonly action: number;
	    constructor(item: ItemType, itemIndex: number, originalEvent: EventObject<Widget>, action: number);
	} namespace internal {
	    class ListView<ItemType> extends CollectionView<Cell<ItemType>> {
	        static selectPrimary(ev: EventObject<Widget>): void;
	        static selectSecondary(ev: EventObject<Widget>): void;
	        static selectToggle(ev: EventObject<Widget>): void;
	        static selectDismiss(ev: EventObject<Widget>): void;
	        static select(ev: EventObject<Widget>, action?: number): void;
	        jsxAttributes: JSXAttributes<this> & Attributes<CollectionView<Cell<ItemType>>> & {
	            children?: Cell[];
	        };
	        onItemsChanged: ChangeListeners<this, 'items'>;
	        onSelect: Listeners<ListViewSelectEvent<ItemType, this>>;
	        private _observer;
	        constructor(properties?: Properties<ListView<ItemType>>);
	        set items(value: ListLike<ItemType>);
	        get items(): ListLike<ItemType>;
	        protected _handleMutation: ({ start, deleteCount, items, target }: Mutation<ItemType>) => void;
	        [JSX.jsxFactory](Type: any, attributes: any): ListView<unknown>;
	    }
	}
	export type ListViewConstructor = typeof internal.ListView;
	export interface ListViewFactory extends Factory<ListViewConstructor>, ListViewConstructor {
	}
	export const ListView: ListViewFactory;
	export type ListView<ItemType> = internal.ListView<ItemType>;
	export {};

}
declare module 'tabris-decorators/index' {
	import { CreateFunction, RegisterFunction, ResolveFunction } from 'tabris-decorators/api/Injector';
	import { InjectDecorator } from 'tabris-decorators/decorators/inject';
	import { InjectableDecorator } from 'tabris-decorators/decorators/injectable';
	import { InjectionHandlerDecorator } from 'tabris-decorators/decorators/injectionHandler';
	import { SharedDecorator } from 'tabris-decorators/decorators/shared';
	export * from 'tabris-decorators/decorators/component';
	export * from 'tabris-decorators/decorators/connect';
	export * from 'tabris-decorators/decorators/property';
	export * from 'tabris-decorators/decorators/prop';
	export * from 'tabris-decorators/decorators/bind';
	export * from 'tabris-decorators/decorators/bindAll';
	export * from 'tabris-decorators/decorators/getById';
	export * from 'tabris-decorators/decorators/event';
	export * from 'tabris-decorators/api/checkType';
	export * from 'tabris-decorators/api/equals';
	export * from 'tabris-decorators/api/convert';
	export * from 'tabris-decorators/api/Injector';
	export * from 'tabris-decorators/api/StateProvider';
	export * from 'tabris-decorators/api/ActionMapper';
	export * from 'tabris-decorators/api/ItemPicker';
	export * from 'tabris-decorators/api/interfaces';
	export * from 'tabris-decorators/api/to';
	export * from 'tabris-decorators/api/List';
	export * from 'tabris-decorators/api/ListView';
	export * from 'tabris-decorators/api/Cell';
	export interface DefaultRootState {
	}
	export interface DefaultActions {
	}
	/**
	 * A decorator that marks a constructor parameter for injections based on the type of the parameter:
	 * ```
	 * constructor(@inject a: ClassA) { ... }
	 * ```
	 * A parameter can be passed to the injector (see `@injectable` and `@injectionHandler`) like this:
	 * ```
	 * constructor(@inject('some value') a: ClassA) { ... }
	 * ```
	 */
	export const inject: InjectDecorator;
	/**
	 * A decorator that makes a class injectable via `@inject` or `resolve(type)`.
	 * It can be injected as itself or as any of its super-classes:
	 *
	 * ```
	 * ‍@injectable class Foo2 extends Foo { ... }
	 * ```
	 * A configuration object can be passed:
	 * ```
	 * ‍@injectable({opt: value})
	 * class Foo2 extends Foo { ... }
	 * ```
	 * The object can have any of these entries:
	 * - `shared: boolean`: when `true`this makes the class effectively a singleton
	 * - `implements: OtherClass`: allows the class to be injected as `OtherClass`
	 * - `priority: number`: The priority of this class relative to other compatible injectables. Defaults to 0.
	 * - `param: value`: allows injection only when `@inject(param)` gives the exact same parameter value.
	 */
	export const injectable: InjectableDecorator;
	/**
	 * Shorthand for `@injectable({shared: true})`.
	 */
	export const shared: SharedDecorator;
	/**
	 * Registers a static method to handle injections for the given type:
	 * ```
	 * ‍@injectionHandler(MyServiceClass)
	 * static createMyServiceClass(injection: Injection) {
	 *   return new MyServiceClass(someArg);
	 * }
	 * ```
	 * A priority may also be given, defaults to 0:
	 * ```ts
	 * @injectionHandler({targetType: MyServiceClass, priority: 2})
	 * ```
	 *
	 * The decorated method must return a value compatible to the given type or `null`/`undefined`.
	 * The method is passed an `Injection` object with the following fields:
	 * - `type`: The exact type that was requested.
	 * - `injector`: The `Injector` instance the injection handler is registered with.
	 * - `param`: An injection parameter that may have been passed via `@inject(param)` or `resolve(type, param)`
	 */
	export const injectionHandler: InjectionHandlerDecorator;
	export const create: CreateFunction;
	export const resolve: ResolveFunction;
	export const register: RegisterFunction;

}
declare module 'tabris-decorators' {
	export * from 'tabris-decorators/index';
}
