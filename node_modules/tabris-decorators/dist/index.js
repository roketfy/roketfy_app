module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("tabris");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isPrimitiveType = exports.hasInjections = exports.getPropertyInfo = exports.getCustomProperties = exports.getParamInfo = exports.getOwnParamInfo = exports.getParameterType = exports.hasPropertyType = exports.getPropertyType = exports.defineGetter = exports.areStaticClassDecoratorArgs = exports.areStaticDecoratorArgs = exports.applyDecorator = void 0;
const paramInfoKey = Symbol('paramInfoKey');
const propInfoKey = Symbol('propInfoKey');
/**
 * Takes a callback a decorator function and when possible calls it with the appropriate arguments,
 * or returns it so it can be can be called later. Rethrows exceptions by the function with an
 * appropriate error message.
 */
function applyDecorator(name, args, decorator) {
    const impl = (widgetProto, property, index) => {
        try {
            return decorator(widgetProto, property, index);
        }
        catch (error) {
            const target = property ? `"${property}"` :
                index !== undefined ? `parameter ${index} of ${widgetProto.name} constructor` :
                    `class ${widgetProto.name}`;
            throw new Error(`Could not apply decorator "${name}" to ${target}: ${error.message}`);
        }
    };
    if (decorator.length === 1 ? areStaticClassDecoratorArgs(args) : areStaticDecoratorArgs(args)) {
        return impl(args[0], args[1], args[2]);
    }
    else {
        return impl;
    }
}
exports.applyDecorator = applyDecorator;
/**
 * Determines whether a decorator was applied with arguments (dynamic, e.g. "@foo(1,2,2)")
 * or without (static, e.g. "@foo").
 */
function areStaticDecoratorArgs(args) {
    const hasClassTarget = (typeof args[0] === 'function') && !!args[0].prototype;
    const hasProtoTarget = (typeof args[0] === 'object') && !!args[0].constructor;
    return (hasClassTarget || hasProtoTarget) && args.length >= 2;
}
exports.areStaticDecoratorArgs = areStaticDecoratorArgs;
/**
 * Determines whether a class decorator was applied with arguments (dynamic, e.g. "@foo(1,2,2)")
 * or without (static, e.g. "@foo").
 */
function areStaticClassDecoratorArgs(args) {
    return typeof args[0] === 'function' && args.length === 1;
}
exports.areStaticClassDecoratorArgs = areStaticClassDecoratorArgs;
/**
 * Defines the a getter on the given prototype. If the prototype already has a getter or setter of that name the
 * function throws.
 */
function defineGetter(proto, property, get) {
    if (Object.getOwnPropertyDescriptor(proto, property)) {
        throw new Error('A getter or setter was already defined.');
    }
    Object.defineProperty(proto, property, {
        get,
        enumerable: true,
        configurable: true
    });
}
exports.defineGetter = defineGetter;
/**
 * Gets the type (constructor) of the property as emitted by tsc.
 * Returns the Object constructor if the type can not be represented
 * by tsc properly at runtime, OR if the compiler option
 * emitDecoratorMetadata is not enabled.
 */
function getPropertyType(proto, property) {
    return Reflect.getMetadata('design:type', proto, property) || Object;
}
exports.getPropertyType = getPropertyType;
/**
 * Returns true if type information was emitted by tsc for this property.
 */
function hasPropertyType(proto, property) {
    return !!Reflect.getMetadata('design:type', proto, property);
}
exports.hasPropertyType = hasPropertyType;
/**
 * Gets the type of the parameter. If the type can not be represented properly at runtime this throw an error.
 */
function getParameterType(fn, index) {
    const result = Reflect.getMetadata('design:paramtypes', fn)[index];
    if (result === Object) {
        throw new Error('Parameter type could not be inferred. Only classes and primitive types are supported.');
    }
    if (!result) {
        throw new Error('Parameter type is undefined: Do you have circular module dependencies?');
    }
    return result;
}
exports.getParameterType = getParameterType;
/**
 * Gets array of injection data for each parameter of the given function
 * If none exists it will be created
 */
function getOwnParamInfo(fn) {
    if (!Reflect.getOwnMetadata(paramInfoKey, fn)) {
        Reflect.defineMetadata(paramInfoKey, [], fn);
    }
    return Reflect.getOwnMetadata(paramInfoKey, fn);
}
exports.getOwnParamInfo = getOwnParamInfo;
/**
 * Gets array of injection data for each parameter of the given function
 * If none exist and the function is a constructor, the super constructor will checked.
 * If none exists in the entire chain, null will be returned.
 */
function getParamInfo(fn) {
    if (!Reflect.getMetadata(paramInfoKey, fn)) {
        // eslint-disable-next-line no-undef
        const orgComponentSym = window.tabris.symbols.originalComponent;
        if (fn[orgComponentSym]) {
            return Reflect.getMetadata(paramInfoKey, fn[orgComponentSym]);
        }
        return null;
    }
    return Reflect.getMetadata(paramInfoKey, fn);
}
exports.getParamInfo = getParamInfo;
function getCustomProperties(target) {
    const result = {};
    for (const prop of Reflect.getMetadataKeys(target, propInfoKey)) {
        result[prop] = getPropertyInfo(target, prop);
    }
    return result;
}
exports.getCustomProperties = getCustomProperties;
function getPropertyInfo(target, prop) {
    if (typeof prop !== 'string') {
        throw new Error('Can not get property info on symbol');
    }
    if (!Reflect.getMetadata(prop, target, propInfoKey)) {
        Reflect.defineMetadata(prop, {}, target, propInfoKey);
    }
    return Reflect.getMetadata(prop, target, propInfoKey);
}
exports.getPropertyInfo = getPropertyInfo;
function hasInjections(fn) {
    const paramInfoArr = getParamInfo(fn);
    if (!paramInfoArr || !paramInfoArr.length) {
        return false;
    }
    for (const paramInfo of paramInfoArr) {
        if (paramInfo && paramInfo.inject) {
            return true;
        }
    }
    return false;
}
exports.hasInjections = hasInjections;
function isPrimitiveType(type) {
    return type === Boolean || type === Number || type === String;
}
exports.isPrimitiveType = isPrimitiveType;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getTarget = exports.checkIsComponent = exports.markAsComponent = exports.checkPathSyntax = exports.parseTargetPath = exports.checkAppended = exports.isAppended = exports.markAsAppended = exports.trigger = exports.checkPropertyExists = exports.getPropertyStore = exports.postAppendHandlers = exports.originalAppendKey = void 0;
const tabris_1 = __webpack_require__(0);
const postAppendHandlersKey = Symbol();
const wasAppendedKey = Symbol();
const propertyStoreKey = Symbol();
const componentKey = Symbol();
exports.originalAppendKey = Symbol();
/**
 * Gets list of functions to be executed after first time append is called on instances of the given
 * widget prototype or instance.
 */
function postAppendHandlers(widget) {
    if (!Reflect.getMetadata(postAppendHandlersKey, widget)) {
        Reflect.defineMetadata(postAppendHandlersKey, [], widget);
    }
    return Reflect.getMetadata(postAppendHandlersKey, widget);
}
exports.postAppendHandlers = postAppendHandlers;
/**
 * Gets map for the purpose of storing property values of the given instance.
 */
function getPropertyStore(instance) {
    if (!instance[propertyStoreKey]) {
        instance[propertyStoreKey] = new Map();
    }
    return instance[propertyStoreKey];
}
exports.getPropertyStore = getPropertyStore;
function checkPropertyExists(targetWidget, targetProperty, targetName = 'Target') {
    let current = targetWidget;
    while (current) {
        const desc = Object.getOwnPropertyDescriptor(current, targetProperty);
        if (desc) {
            if (!desc.set) {
                throw new Error(`${targetName} property "${targetProperty}" has no setter, missing @property?`);
            }
            return;
        }
        current = Object.getPrototypeOf(current);
    }
    throw new Error(`${targetName} does not have a property "${targetProperty}".`);
}
exports.checkPropertyExists = checkPropertyExists;
function trigger(target, type, eventData) {
    tabris_1.Listeners.getListenerStore(target).trigger(type, eventData);
}
exports.trigger = trigger;
function markAsAppended(widget) {
    widget[wasAppendedKey] = true;
}
exports.markAsAppended = markAsAppended;
function isAppended(widget) {
    return !!widget[wasAppendedKey];
}
exports.isAppended = isAppended;
function checkAppended(widget) {
    if (!isAppended(widget)) {
        throw new Error('No widgets have been appended yet.');
    }
}
exports.checkAppended = checkAppended;
function parseTargetPath(targetPath) {
    const { path, direction } = extractDirection(targetPath);
    checkPathSyntax(path);
    if (!/^[A-Z#.]/.test(path) && !path.startsWith(':host')) {
        throw new Error('Binding path must start with direction or selector.');
    }
    if (path.startsWith('.')) {
        throw new Error('Class selectors are not allowed.');
    }
    const segments = path.split('.');
    if (segments.length < 2) {
        throw new Error('Binding path needs at least two segments.');
    }
    else if (segments.length > 2) {
        throw new Error('Binding path has too many segments.');
    }
    return [direction, segments[0], segments[1]];
}
exports.parseTargetPath = parseTargetPath;
function checkPathSyntax(targetPath) {
    if (/\s|\[|\]|\(|\)|<|>/.test(targetPath)) {
        throw new Error('Binding path contains invalid characters.');
    }
}
exports.checkPathSyntax = checkPathSyntax;
function extractDirection(path) {
    if (path.startsWith('<') || path.startsWith('>')) {
        const split = /^(<<|>>)\s*(.*)$/.exec(path);
        if (!split || split.length !== 3) {
            throw new Error('Invalid path prefix.');
        }
        return { path: split[2], direction: split[1] };
    }
    return { path, direction: '' };
}
function markAsComponent(type) {
    Reflect.defineMetadata(componentKey, true, type.prototype);
}
exports.markAsComponent = markAsComponent;
function checkIsComponent(widget) {
    if (!Reflect.getMetadata(componentKey, widget)) {
        throw new Error(`${widget.constructor.name} is not a @component`);
    }
}
exports.checkIsComponent = checkIsComponent;
function getTarget(base, selector) {
    if (selector === ':host') {
        return base;
    }
    const results = base._find(selector);
    if (results.length === 0) {
        throw new Error(`No widget matching "${selector}" was appended.`);
    }
    else if (results.length > 1) {
        throw new Error(`Multiple widgets matching "${selector}" were appended.`);
    }
    return results.first();
}
exports.getTarget = getTarget;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("reflect-metadata");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomPropertyDescriptor = exports.autoDefault = void 0;
const utils_1 = __webpack_require__(1);
const utils_databinding_1 = __webpack_require__(2);
const checkType_1 = __webpack_require__(6);
const convert_1 = __webpack_require__(12);
const equals_1 = __webpack_require__(13);
exports.autoDefault = Symbol('autoDefault');
class CustomPropertyDescriptor {
    constructor(proto, propertyName) {
        this.proto = proto;
        this.propertyName = propertyName;
        this.enumerable = true;
        this.configurable = true;
        this.targetType = utils_1.getPropertyType(this.proto, this.propertyName);
        this.youHaveBeenWarned = false;
        const self = this;
        this.changeEvent = propertyName + 'Changed';
        this.set = function (value) { self.setValue(this, value); };
        this.get = function () { return self.getValue(this); };
        Object.defineProperty(proto, propertyName, this);
        this.setCompareMode('strict');
        this.setConverter('off');
        this.setNullable(true);
        this.setDefaultValue(undefined);
        this.setInitializer(undefined);
        this.setReadonly(false);
    }
    static get(proto, propertyName) {
        let descriptor = Reflect.getMetadata(this.metaDataKey, proto, propertyName);
        if (!descriptor) {
            descriptor = new CustomPropertyDescriptor(proto, propertyName);
            Reflect.defineMetadata(this.metaDataKey, descriptor, proto, propertyName);
        }
        else if (!(descriptor instanceof CustomPropertyDescriptor)) {
            throw new Error(`Property "${descriptor}" can not be re-defined`);
        }
        return descriptor;
    }
    static isUnchecked(target, propertyName) {
        const desc = Reflect.getMetadata(this.metaDataKey, target, propertyName);
        if (desc instanceof CustomPropertyDescriptor) {
            return desc.isUnchecked();
        }
        return false;
    }
    static has(target, propertyName) {
        return !!Reflect.getMetadata(this.metaDataKey, target, propertyName);
    }
    addConfig(config) {
        if (config.readonly) {
            this.setReadonly(config.readonly);
        }
        if (config.initializer) {
            this.setInitializer(config.initializer);
        }
        if (config.type) {
            this.setUserType(config.type);
        }
        if (config.typeGuard) {
            this.addTypeGuard(config.typeGuard);
        }
        if (config.convert) {
            this.setConverter(config.convert);
        }
        if (config.equals) {
            this.setCompareMode(config.equals);
        }
        if (config.nullable != null) {
            this.setNullable(config.nullable);
        }
        if ('default' in config) {
            this.setDefaultValue(config.default);
        }
    }
    setValue(instance, value) {
        if (this.readonly) {
            throw new TypeError('Property is read-only');
        }
        let newValue = this.convert(value, instance);
        if (newValue == null && !this.nullable) {
            if (this.defaultValue == null) {
                throw new TypeError('Property is not nullable');
            }
            newValue = this.convert(this.defaultValue, instance);
        }
        if (!this.equals(this.getValue(instance), newValue)) {
            if (!this.isUnchecked()) {
                this.checkType(newValue);
            }
            utils_databinding_1.getPropertyStore(instance).set(this.propertyName, newValue);
            utils_databinding_1.trigger(instance, this.changeEvent, { value: newValue });
        }
    }
    getValue(instance) {
        const store = utils_databinding_1.getPropertyStore(instance);
        if (!store.has(this.propertyName)) {
            store.set(this.propertyName, undefined);
            if (this.initializer || (this.defaultValue !== undefined)) {
                const rawValue = this.initializer ? this.initializer(instance, this) : this.defaultValue;
                try {
                    const initValue = this.convert(rawValue, instance);
                    if (!this.isUnchecked()) {
                        this.checkType(initValue);
                    }
                    store.set(this.propertyName, initValue);
                }
                catch (ex) {
                    const message = `Failed to initialize property "${this.propertyName}" with default value: ${ex.message}`;
                    console.warn(message);
                }
            }
            else {
                store.set(this.propertyName, undefined);
            }
        }
        return store.get(this.propertyName);
    }
    isUnchecked() {
        return this.targetType === Object
            && !this.userType
            && !this.typeGuard;
    }
    checkType(value) {
        try {
            if (this.userType) { // unlike meta-data type, userType is checked first and regardless of typeGuard
                checkType_1.checkType(value, this.userType);
            }
            if (this.typeGuard) {
                if (!this.typeGuard(value)) {
                    throw new Error('Type guard check failed');
                }
            }
            else if (!this.userType) {
                checkType_1.checkType(value, this.targetType);
            }
        }
        catch (ex) {
            throw new TypeError(`Failed to set property "${this.propertyName}": ${ex.message}`);
        }
    }
    setUserType(type) {
        if (this.userType) {
            throw new Error('Can not re-define type of property');
        }
        this.userType = type;
    }
    addTypeGuard(typeGuard) {
        if (!this.typeGuard) {
            this.typeGuard = typeGuard;
        }
        else {
            const prevTypeGuard = this.typeGuard;
            this.typeGuard = value => typeGuard(value) && prevTypeGuard(value);
        }
    }
    setCompareMode(mode) {
        this.equals = (a, b) => equals_1.equals([a, b], mode);
    }
    setInitializer(initializer) {
        this.initializer = initializer;
    }
    setConverter(modeOrFn) {
        if (modeOrFn === 'off') {
            this.convert = value => value;
        }
        else if (modeOrFn === 'auto') {
            this.convert = value => {
                if (this.isConvertible(value)) {
                    return convert_1.convert(value, this.getType());
                }
                return value;
            };
        }
        else if (modeOrFn instanceof Function) {
            this.convert = value => {
                if (this.isConvertible(value)) {
                    return modeOrFn(value);
                }
                return value;
            };
        }
    }
    setNullable(nullable) {
        this.nullable = nullable !== false;
    }
    setReadonly(readonly) {
        this.readonly = readonly;
    }
    setDefaultValue(value) {
        if (this.defaultValue !== undefined) {
            throw new Error('property default value can not be re-defined');
        }
        if (value === exports.autoDefault) {
            const type = this.getType();
            if (type == null) {
                this.handleTypeMissing();
            }
            else {
                this.defaultValue =
                    type === Number ? 0 :
                        type === String ? '' :
                            type === Boolean ? false :
                                null;
            }
        }
        else {
            this.defaultValue = value;
        }
    }
    getType() {
        return this.userType || (this.targetType !== Object ? this.targetType : null);
    }
    isConvertible(value) {
        const type = this.getType();
        if (!type) {
            this.handleTypeMissing();
            return false;
        }
        if (value == null) {
            return false;
        }
        return !checkType_1.isType(value, type, true);
    }
    handleTypeMissing() {
        if (!this.youHaveBeenWarned) {
            const className = this.proto.constructor.name || '[anonymous]';
            console.warn(`Property "${this.propertyName}" of class "${className}" requires an explicit type to function correctly`);
            this.youHaveBeenWarned = true;
        }
    }
}
exports.CustomPropertyDescriptor = CustomPropertyDescriptor;
CustomPropertyDescriptor.metaDataKey = Symbol();


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.injector = exports.Injector = void 0;
const inject_1 = __webpack_require__(21);
const injectable_1 = __webpack_require__(22);
const injectionHandler_1 = __webpack_require__(23);
const shared_1 = __webpack_require__(24);
const ExtendedJSX_1 = __webpack_require__(7);
const utils_1 = __webpack_require__(1);
const injectorKey = Symbol('injectorKey');
/**
 * An `Injector` instance manages injection handlers and fulfills injections.
 *
 * You may create your own instance of `Injector` if you wish to keep your injection
 * handlers separate from those kept in the global `injector` object exported
 * by `tabris-decorators`. You must then use the attached decorators and `JSX` object
 * instead of the global ones.
 */
class Injector {
    constructor() {
        this.injectionHandler = injectionHandler_1.bindDecoratorInjectionHandler(this);
        this.inject = inject_1.bindDecoratorInject(this);
        this.injectable = injectable_1.bindDecoratorInjectable(this);
        this.shared = shared_1.bindDecoratorShared(this);
        /**
         * This object needs to be present in the module namespace to allow JSX expressions that
         * use this `Injector` instance to fulfill injections. E.g.
         * ```
         *   const JSX = injector.jsxProcessor; // shadows global JSX object
         * ```
         * Or to set it as the default for all JSX elements globally:
         * ```
         *   JSX.install(injector.jsxProcessor);
         * ```
         */
        this.jsxProcessor = new ExtendedJSX_1.ExtendedJSX(this);
        this.handlers = new Map();
        this.injectionStack = [];
        this.resolveQueue = [];
        /**
         * Registers a value as a shared injectable for the given type.
         * Equivalent to calling `addHandler(type, () => value)` or using
         * `@shared`.
         */
        this.register = (targetType, value) => {
            this.addHandler(targetType, () => value);
            return value;
        };
        /**
         * Explicitly registers a new injection handler. Same as using the attached `injectionHandler`
         * decorator.
         */
        this.addHandler = (arg1, arg2) => {
            const param = (arg1 instanceof Function ? { targetType: arg1, handler: arg2 } : arg1);
            if (!param.targetType || !param.handler) {
                throw new Error('invalid argument');
            }
            this.forEachPrototype(param.targetType, (prototype) => {
                const targetTypeHandlers = this.handlers.get(prototype) || [];
                const ref = targetTypeHandlers.findIndex(reg => (reg.priority || 0) <= (param.priority || 0));
                targetTypeHandlers.splice(ref < 0 ? targetTypeHandlers.length : ref, 0, param);
                this.handlers.set(prototype, targetTypeHandlers);
            });
        };
        /**
         * Returns an instance for an injectable type, just like using the `@inject` decorator
         * would do in a constructor.
         */
        this.resolve = (type, param = null) => {
            const regs = this.findHandlerRegistrations(type);
            if (!regs.length) {
                if (type === Injector) {
                    return this;
                }
                throw new Error(`Could not inject value of type ${type.name} since no compatible injection handler exists for this type.`);
            }
            if (this.injectionStack.indexOf(type) !== -1) {
                const stackString = this.injectionStack.concat(type).map(constructor => constructor.name).join(' -> ');
                throw new Error('Circular dependency injection: ' + stackString);
            }
            const unbox = this.getUnboxer(type);
            for (const reg of regs) {
                this.injectionStack.push(type);
                let result = null;
                try {
                    result = unbox(reg.handler({ type, injector: this, param }));
                }
                finally {
                    this.injectionStack.pop();
                    if (!result) {
                        this.resolveQueue = [];
                    }
                }
                this.scheduleResolveProperties(result);
                this.resolvePropertyInjections();
                if (result !== null && result !== undefined) {
                    return this.tagResult(result);
                }
            }
            throw new Error(`Could not inject value of type ${type.name} since no compatible injection handler returned a value.`);
        };
        /**
         * `create(type: Class, ...parameters: any[])`
         *
         * Creates an instance of the given class and fills in all the constructor parameters decorated with `@inject`.
         * Parameters given after the type will be passed to the constructor, potentially overriding
         * the injection value.
         */
        this.create = (type, arg1, arg2, arg3, ...remaining) => {
            if (!type) {
                throw new Error('No type to create was given');
            }
            try {
                const args = [arg1, arg2, arg3].concat(remaining);
                const finalArgs = [];
                const paramInfo = utils_1.getParamInfo(type) || [];
                const paramCount = Math.max(type.length, args.length, paramInfo.length);
                for (let i = 0; i < paramCount; i++) {
                    if (args[i] === undefined && paramInfo[i]) {
                        finalArgs[i] = this.resolve(paramInfo[i].type, paramInfo[i].injectParam || null);
                    }
                    else {
                        finalArgs[i] = args[i];
                    }
                }
                const result = new type(...finalArgs);
                this.scheduleResolveProperties(result);
                this.resolvePropertyInjections();
                return this.tagResult(result);
            }
            catch (ex) {
                throw new Error(`Could not create instance of ${type.name}:\n${ex.message}`);
            }
        };
    }
    /**
     * Returns the instance of Injector that was used to create the given object.
     * Given a class decorated with @inject or @shared it returns the injector
     * associated with these.
     */
    static get(object, fallback) {
        if (!object || !(object instanceof Object)) {
            throw new Error('Injector.get does not accept values of type ' + typeof object);
        }
        if (injectorKey in object) {
            return object[injectorKey];
        }
        if (Reflect.getMetadata(injectable_1.injectableKey, object)) {
            return Reflect.getMetadata(injectable_1.injectableKey, object);
        }
        if (fallback) {
            return fallback;
        }
        if (object instanceof Function && object.prototype instanceof Object && object.prototype.constructor !== Object) {
            throw new Error('Can not get injector for a class that is not decorated with @injectable');
        }
        throw new Error('Object was not created by an Injector');
    }
    scheduleResolveProperties(result) {
        if (result instanceof Object && this.resolveQueue.indexOf(result) === -1) {
            this.resolveQueue.push(result);
        }
    }
    resolvePropertyInjections() {
        if (this.injectionStack.length === 0 && this.resolveQueue.length) {
            const queue = this.resolveQueue;
            this.resolveQueue = [];
            while (queue.length) {
                const resolved = queue.shift();
                if (resolved instanceof Object) {
                    const props = utils_1.getCustomProperties(resolved);
                    for (const prop of Object.keys(props)) {
                        if (props[prop].inject) {
                            try {
                                if (!resolved[prop]) {
                                    throw new Error(`Property is ${resolved[prop]}`);
                                }
                            }
                            catch (ex) {
                                throw new Error(`Property "${prop}" of ${resolved.constructor.name} was not resolved: ${ex.message}`);
                            }
                        }
                    }
                }
            }
        }
    }
    findHandlerRegistrations(type) {
        if (!type) {
            throw new Error(`Could not inject value since type is ${type}. You may have a broken import, circular module dependencies or an incorrect tsconfig.json configuration.`);
        }
        return this.handlers.get(type.prototype) || [];
    }
    getUnboxer(type) {
        if (type === Number || type === String || type === Boolean) {
            return this.unboxValue;
        }
        return this.passValue;
    }
    passValue(value) {
        return value;
    }
    unboxValue(box) {
        return box !== null && box !== undefined ? box.valueOf() : box;
    }
    forEachPrototype(type, cb) {
        let currentProto = type.prototype;
        while (currentProto !== Object.prototype) {
            cb(currentProto);
            currentProto = Object.getPrototypeOf(currentProto);
        }
    }
    tagResult(value) {
        if (value instanceof Object) {
            value[injectorKey] = this;
        }
        return value;
    }
}
exports.Injector = Injector;
exports.injector = new Injector();


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getTypeName = exports.getValueString = exports.isType = exports.checkType = void 0;
const utils_1 = __webpack_require__(1);
/**
 * Performs type checks on the given value. If the check fails the function throws an error message stating the reason.
 *
 * The following rules apply:
 * * Object constructor passes any value
 * * Object values may be an instance of the given class or any class extending it.
 * * Primitive types are represented by their boxed type, e.g. a number is `Number`.
 * * Null and undefined pass unless 'strict' is true
 * * Boxed values never pass.
 */
function checkType(value, type, strict) {
    if (!type) {
        throw new Error('No type given');
    }
    if (isBoxedValue(value)) {
        throw new Error('Boxed values are forbidden');
    }
    if (!isType(value, type, strict)) {
        throw new Error(`Expected ${getValueString(value)} to be of type ${getTypeName(type)}, but found ${getValueTypeName(value)}.`);
    }
}
exports.checkType = checkType;
function isType(value, type, strict) {
    if (!type || type === Object) {
        return true;
    }
    if (!strict && (value === null || value === undefined)) {
        return true;
    }
    if (value instanceof type || isPrimitiveOfType(value, type)) {
        return true;
    }
    return false;
}
exports.isType = isType;
function getValueString(value) {
    let result = 'value';
    if (value === '') {
        result += ' [empty string]';
    }
    else if (isPrimitiveValue(value)) {
        return result += ` "${value}"`;
    }
    return result;
}
exports.getValueString = getValueString;
function getTypeName(type) {
    const name = type.name;
    if (utils_1.isPrimitiveType(type)) {
        return name.toLowerCase();
    }
    return name;
}
exports.getTypeName = getTypeName;
function getValueTypeName(value) {
    if (value && value.constructor) {
        return getTypeName(value.constructor);
    }
    if (value === null) {
        return 'null';
    }
    return typeof value;
}
function isPrimitiveOfType(value, type) {
    if (!utils_1.isPrimitiveType(type)) {
        return false;
    }
    return typeof value === getTypeName(type);
}
function isBoxedValue(value) {
    return value instanceof Boolean || value instanceof Number || value instanceof String;
}
function isPrimitiveValue(value) {
    return typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string';
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtendedJSX = exports.setInjectorOverride = exports.getJsxInfo = void 0;
const tabris_1 = __webpack_require__(0);
const applyJsxBindings_1 = __webpack_require__(14);
const utils_1 = __webpack_require__(1);
function getJsxInfo(source) {
    if (source instanceof Object && source[jsxInfo]) {
        return source[jsxInfo];
    }
    return { source };
}
exports.getJsxInfo = getJsxInfo;
function setInjectorOverride(target, injector) {
    target[jsxInjectorOverride] = injector;
}
exports.setInjectorOverride = setInjectorOverride;
class ExtendedJSX extends tabris_1.JsxProcessor {
    constructor(injector) {
        super();
        this.injector = injector;
        this.unsafeBindings = 'warn';
    }
    createCustomComponent(type, attributes) {
        const result = super.createCustomComponent(type, attributes);
        if (result instanceof Object) {
            const { children } = attributes, pureAttributes = __rest(attributes, ["children"]);
            result[jsxInfo] = {
                processor: this,
                componentType: type,
                sfc: null,
                attributes: pureAttributes,
                children: children ? children.map(getJsxInfo) : null
            };
        }
        return result;
    }
    createFunctionalComponent(type, attributes) {
        const result = super.createFunctionalComponent(type, attributes);
        if (result instanceof Object) {
            const { children } = attributes, pureAttributes = __rest(attributes, ["children"]);
            result[jsxInfo] = {
                processor: this,
                componentType: null,
                sfc: type,
                attributes: pureAttributes,
                children: (children || []).map(getJsxInfo)
            };
        }
        return result;
    }
    createNativeObject(Type, attributes) {
        const { miscAttributes, bindings } = this.extractBindings(attributes);
        const result = super.createNativeObject(this.convertType(Type), miscAttributes || {});
        if (bindings && result instanceof tabris_1.Widget) {
            applyJsxBindings_1.applyJsxBindings(result, bindings, this.unsafeBindings);
        }
        return result;
    }
    extractBindings(attributes) {
        let miscAttributes;
        let bindings;
        for (const attribute in attributes) {
            if (attribute.startsWith('bind-') || attribute.startsWith('template-')) {
                if (!bindings) {
                    bindings = {};
                }
                bindings[attribute] = attributes[attribute];
            }
            else {
                if (!miscAttributes) {
                    miscAttributes = {};
                }
                miscAttributes[attribute] = attributes[attribute];
            }
        }
        return { miscAttributes, bindings };
    }
    convertType(type) {
        if (utils_1.hasInjections(type) || type[jsxInjectorOverride]) {
            const injector = type[jsxInjectorOverride] || this.injector;
            return function (props) {
                return injector.create(type, props);
            };
        }
        return type;
    }
}
exports.ExtendedJSX = ExtendedJSX;
const jsxInfo = Symbol('jsxInfo');
const jsxInjectorOverride = Symbol('jsxInjectorOverride');


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.event = void 0;
const tabris_1 = __webpack_require__(0);
const utils_databinding_1 = __webpack_require__(2);
/**
 * A decorator that can be attached to a property of the type `Listeners`.
 *
 * The name of the property must start with "on", e.g. "onMyEvent".
 * The property will become read-only and contain a `Listeners` instance
 * that is configured to dispatch events on the object it is attached to.
 *
 * When used on a widget the `Listeners` instance will be integrated in
 * the existing event system. Events triggered via one API will also be issued via the other.
 */
function event(targetProto, evPropertyName) {
    const evPropertyType = Reflect.getMetadata('design:type', targetProto, evPropertyName);
    checkPropertyType(evPropertyType, evPropertyName);
    checkPropertyName(evPropertyName, evPropertyType);
    if (evPropertyName.endsWith('Changed')) {
        defineGetter(targetProto, evPropertyName, function () {
            const targetInstance = this;
            const propertyName = eventType(evPropertyName).slice(0, -7);
            const store = utils_databinding_1.getPropertyStore(targetInstance);
            if (!store[evPropertyName]) {
                store[evPropertyName] = new tabris_1.ChangeListeners(targetInstance, propertyName);
            }
            return store[evPropertyName];
        });
    }
    else {
        defineGetter(targetProto, evPropertyName, function () {
            const targetInstance = this;
            const store = utils_databinding_1.getPropertyStore(targetInstance);
            if (!store[evPropertyName]) {
                store[evPropertyName] = new tabris_1.Listeners(targetInstance, eventType(evPropertyName));
            }
            return store[evPropertyName];
        });
    }
}
exports.event = event;
function defineGetter(target, property, getter) {
    Object.defineProperty(target, property, {
        get: getter,
        enumerable: true,
        configurable: false
    });
}
function eventType(evPropertyName) {
    return evPropertyName.charAt(2).toLowerCase() + evPropertyName.slice(3);
}
function checkPropertyType(propertyType, propertyName) {
    if (propertyType
        && (propertyType !== Object)
        && (propertyType !== tabris_1.Listeners)
        && (propertyType !== tabris_1.ChangeListeners)) {
        throw new Error(`@event: Invalid type for property ${propertyName}`);
    }
}
function checkPropertyName(propertyName, propertyType) {
    if (!/^on[A-Z]/.test(propertyName)) {
        throw new Error(`@event: Invalid name for property ${propertyName}`);
    }
    if (propertyType === tabris_1.ChangeListeners) {
        if (!/^on[A-Z].*Changed$/.test(propertyName)) {
            throw new Error(`@event: Invalid name for property ${propertyName}`);
        }
    }
}


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.component = void 0;
__webpack_require__(3);
const tabris_1 = __webpack_require__(0);
const utils_databinding_1 = __webpack_require__(2);
const ExtendedJSX_1 = __webpack_require__(7);
const processOneWayBindings_1 = __webpack_require__(25);
const utils_1 = __webpack_require__(1);
function component(arg) {
    return utils_1.applyDecorator('component', [arg], (type) => {
        const options = arg instanceof Function ? {} : arg;
        utils_databinding_1.markAsComponent(type);
        isolate(type);
        addOneWayBindingsProcessor(type);
        patchAppend(type);
        if (options.injector) {
            ExtendedJSX_1.setInjectorOverride(type, options.injector);
        }
        return type;
    });
}
exports.component = component;
function isolate(type) {
    if (type.prototype.children !== returnEmptyCollection) {
        type.prototype.children = returnEmptyCollection;
    }
}
function addOneWayBindingsProcessor(type) {
    const handlers = utils_databinding_1.postAppendHandlers(type.prototype);
    if (handlers.indexOf(oneWayBindingsProcessor) === -1) {
        handlers.push(oneWayBindingsProcessor);
    }
}
function oneWayBindingsProcessor(base) {
    base._find().forEach(child => processOneWayBindings_1.processOneWayBindings(base, child));
}
function returnEmptyCollection() {
    return new tabris_1.WidgetCollection([]);
}
function patchAppend(type) {
    const widgetProto = type.prototype;
    if (widgetProto.append !== customAppend) {
        widgetProto[utils_databinding_1.originalAppendKey] = widgetProto.append;
        widgetProto.append = customAppend;
    }
}
function customAppend() {
    const result = this[utils_databinding_1.originalAppendKey].apply(this, arguments);
    if (!utils_databinding_1.isAppended(this)) {
        utils_databinding_1.markAsAppended(this);
        runPostAppendHandler(this);
    }
    return result;
}
function runPostAppendHandler(widgetInstance) {
    for (const fn of utils_databinding_1.postAppendHandlers(widgetInstance)) {
        fn(widgetInstance);
    }
}


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.supportsChangeEvents = exports.subscribe = void 0;
const tabris_1 = __webpack_require__(0);
const CustomPropertyDescriptor_1 = __webpack_require__(4);
const force = Symbol();
function subscribe(root, path, cb) {
    checkParameter(root, path, cb);
    const [rootProperty, ...subProperties] = path;
    let currentValue;
    let cancel;
    const listener = (mode) => {
        if ((mode === force) || (currentValue !== root[rootProperty])) {
            currentValue = root[rootProperty];
            if (subProperties.length) {
                if (cancel) {
                    cancel();
                }
                if (currentValue && (currentValue instanceof Object)) {
                    cancel = subscribe(currentValue, subProperties, cb);
                }
                else if (currentValue == null) {
                    cb(undefined);
                }
                else {
                    throw new TypeError(`Value of property "${rootProperty}" is of type ${typeof currentValue}, expected object`);
                }
            }
            else {
                cb(currentValue);
            }
        }
    };
    addChangeListener(root, rootProperty, listener);
    listener(force);
    return () => {
        removeChangeListener(root, rootProperty, listener);
        if (cancel) {
            cancel();
        }
    };
}
exports.subscribe = subscribe;
function checkParameter(root, path, cb) {
    if (!(root instanceof Object)) {
        throw new Error('root is not an Object');
    }
    if (!(path instanceof Array)) {
        throw new Error('path is not an Array');
    }
    if (path.length === 0) {
        throw new Error('path is not an Array');
    }
    if (path.some(entry => !entry)) {
        throw new Error('path contains invalid entries');
    }
    if (!(cb instanceof Function)) {
        throw new Error('callback is not a function');
    }
}
function addChangeListener(target, property, listener) {
    if (supportsChangeEvents(target, property)) {
        tabris_1.Listeners.getListenerStore(target).on(property + 'Changed', listener);
    }
}
function removeChangeListener(target, property, listener) {
    if (supportsChangeEvents(target, property)) {
        tabris_1.Listeners.getListenerStore(target).off(property + 'Changed', listener);
    }
}
function supportsChangeEvents(target, targetProperty) {
    if (target instanceof tabris_1.NativeObject) {
        return true; // anyone could fire change events
    }
    const changeEvent = targetProperty + 'Changed';
    const listenerProperty = 'on' + changeEvent.charAt(0).toUpperCase() + changeEvent.slice(1);
    const listeners = target[listenerProperty];
    if (listeners && listeners.original instanceof tabris_1.Listeners) {
        if (listeners.original.target !== target || listeners.original.type !== changeEvent) {
            throw new Error(listenerProperty + ' has wrong target or event type');
        }
        return true;
    }
    return CustomPropertyDescriptor_1.CustomPropertyDescriptor.has(target, targetProperty);
}
exports.supportsChangeEvents = supportsChangeEvents;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = exports.resolve = exports.create = exports.injectionHandler = exports.shared = exports.injectable = exports.inject = void 0;
const Injector_1 = __webpack_require__(5);
// NOTE: The JsDoc for decorators in this file are necessary duplicates from those attached to the implementation.
// Those here are displayed in VS code when using the decorator without parameters.
__exportStar(__webpack_require__(9), exports);
__exportStar(__webpack_require__(26), exports);
__exportStar(__webpack_require__(16), exports);
__exportStar(__webpack_require__(27), exports);
__exportStar(__webpack_require__(17), exports);
__exportStar(__webpack_require__(29), exports);
__exportStar(__webpack_require__(30), exports);
__exportStar(__webpack_require__(8), exports);
__exportStar(__webpack_require__(6), exports);
__exportStar(__webpack_require__(13), exports);
__exportStar(__webpack_require__(12), exports);
__exportStar(__webpack_require__(5), exports);
__exportStar(__webpack_require__(15), exports);
__exportStar(__webpack_require__(31), exports);
__exportStar(__webpack_require__(32), exports);
__exportStar(__webpack_require__(33), exports);
__exportStar(__webpack_require__(34), exports);
__exportStar(__webpack_require__(18), exports);
__exportStar(__webpack_require__(35), exports);
__exportStar(__webpack_require__(20), exports);
/**
 * A decorator that marks a constructor parameter for injections based on the type of the parameter:
 * ```
 * constructor(@inject a: ClassA) { ... }
 * ```
 * A parameter can be passed to the injector (see `@injectable` and `@injectionHandler`) like this:
 * ```
 * constructor(@inject('some value') a: ClassA) { ... }
 * ```
 */
exports.inject = Injector_1.injector.inject;
/**
 * A decorator that makes a class injectable via `@inject` or `resolve(type)`.
 * It can be injected as itself or as any of its super-classes:
 *
 * ```
 * @injectable class Foo2 extends Foo { ... }
 * ```
 * A configuration object can be passed:
 * ```
 * @injectable({opt: value})
 * class Foo2 extends Foo { ... }
 * ```
 * The object can have any of these entries:
 * - `shared: boolean`: when `true`this makes the class effectively a singleton
 * - `implements: OtherClass`: allows the class to be injected as `OtherClass`
 * - `priority: number`: The priority of this class relative to other compatible injectables. Defaults to 0.
 * - `param: value`: allows injection only when `@inject(param)` gives the exact same parameter value.
 */
exports.injectable = Injector_1.injector.injectable;
/**
 * Shorthand for `@injectable({shared: true})`.
 */
exports.shared = Injector_1.injector.shared;
/**
 * Registers a static method to handle injections for the given type:
 * ```
 * @injectionHandler(MyServiceClass)
 * static createMyServiceClass(injection: Injection) {
 *   return new MyServiceClass(someArg);
 * }
 * ```
 * A priority may also be given, defaults to 0:
 * ```ts
 * @injectionHandler({targetType: MyServiceClass, priority: 2})
 * ```
 *
 * The decorated method must return a value compatible to the given type or `null`/`undefined`.
 * The method is passed an `Injection` object with the following fields:
 * - `type`: The exact type that was requested.
 * - `injector`: The `Injector` instance the injection handler is registered with.
 * - `param`: An injection parameter that may have been passed via `@inject(param)` or `resolve(type, param)`
 */
exports.injectionHandler = Injector_1.injector.injectionHandler;
exports.create = Injector_1.injector.create;
exports.resolve = Injector_1.injector.resolve;
exports.register = Injector_1.injector.register;
JSX.install(Injector_1.injector.jsxProcessor);


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.convert = void 0;
const tabris_1 = __webpack_require__(0);
const checkType_1 = __webpack_require__(6);
const floatRegEx = /^[+-]?([0-9]+|[0-9]*\.[0-9]+)$/;
const staticNumbers = Object.freeze({
    '': 0,
    'nan': NaN,
    'infinity': Infinity,
    '-infinity': -Infinity
});
const staticBoolean = Object.freeze({
    '': false,
    '1': true,
    '0': false,
    'true': true,
    'false': false
});
const typedArrayTypes = Object.freeze([
    Int8Array, Int8Array, Int16Array, Int32Array,
    Uint8Array, Uint8Array, Uint16Array, Uint32Array,
    Uint8ClampedArray, Float32Array, Float64Array, ArrayBuffer
]);
function convert(value, type) {
    if (!(type instanceof Function) || type === Object || !type.prototype) {
        throw new Error('Invalid type');
    }
    if (type === tabris_1.NativeObject || type.prototype instanceof tabris_1.NativeObject) {
        throw new Error('Invalid type');
    }
    try {
        if (type === Number) {
            return toNumber(value);
        }
        else if (type === Boolean) {
            return toBoolean(value);
        }
        else if (type === String) {
            return toString(value);
        }
        else if (type === Array) {
            return toArray(value);
        }
        else if (typedArrayTypes.indexOf(type) !== -1) {
            return toTypedArray(value, type);
        }
        return toObject(value, type);
    }
    catch (ex) {
        fail(value, type, ex);
    }
}
exports.convert = convert;
function toNumber(value) {
    if (value == null) {
        return 0;
    }
    else if (typeof value === 'number') {
        return value;
    }
    else if (typeof value === 'boolean') {
        return value ? 1 : 0;
    }
    else if (typeof value === 'string') {
        return stringToNumber(value);
    }
    else if (value instanceof Object) {
        return objectToNumber(value);
    }
    fail(value, Number);
}
function toBoolean(value) {
    if (value == null) {
        return false;
    }
    else if (typeof value === 'number') {
        return !isNaN(value) && value > 0;
    }
    else if (typeof value === 'boolean') {
        return value;
    }
    else if (typeof value === 'string') {
        return stringToBoolean(value);
    }
    else if (value instanceof Object) {
        return objectToBoolean(value);
    }
    fail(value, Boolean);
}
function toString(value) {
    if (value == null) {
        return '';
    }
    else if (typeof value === 'number') {
        return isNaN(value) ? '' : String(value).toLocaleLowerCase();
    }
    else if (value instanceof Object) {
        return objectToString(value);
    }
    return String(value);
}
function toArray(value) {
    if (value instanceof Array) {
        return value;
    }
    else if (value instanceof Object) {
        if (value instanceof Function) {
            return [unwrapObject(value)];
        }
        else if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
            return Array.from(new Uint8ClampedArray(value instanceof ArrayBuffer ? value : value.buffer));
        }
        else if (isArrayLike(value)) {
            return Array.from(value);
        }
        else if (hasConverter(value, 'toArray')) {
            return value.toArray();
        }
        return Object.keys(value).map(key => value[key]);
    }
    else if (typeof value === 'string') {
        return value.split(',').map(part => part.trim());
    }
    return [value];
}
function toTypedArray(value, type) {
    if (value instanceof type) {
        return value;
    }
    else if (ArrayBuffer.isView(value) && type === ArrayBuffer) {
        return value.buffer;
    }
    else if (ArrayBuffer.isView(value)) {
        return new type(value.buffer);
    }
    else if (value instanceof ArrayBuffer) {
        return new type(value);
    }
    else if (typeof value === 'string') {
        throw new Error('Not supported');
    }
    const targetType = type === ArrayBuffer ? Uint8ClampedArray : type;
    const typedArray = new targetType(toArray(value).map(toNumber));
    if (type === ArrayBuffer) {
        return typedArray.buffer;
    }
    return typedArray;
}
function toObject(value, type) {
    if (value instanceof type) {
        return value;
    }
    else if (typeof value === 'string' && hasFactory(type, 'parse')) {
        return verify(type.parse(value), type, 'Static method "parse"');
    }
    else if (hasFactory(type, 'from')) {
        return verify(type.from(value), type, 'Static method "from"');
    }
    else if (type.length > 0) {
        return new type(value);
    }
    fail(value, type);
}
function stringToNumber(value) {
    const normal = value.trim().toLowerCase();
    if (normal in staticNumbers) {
        return staticNumbers[normal];
    }
    else if (normal.startsWith('0x')) {
        return notNaN(parseInt(normal, 16));
    }
    else if (floatRegEx.test(normal)) {
        return notNaN(parseFloat(value));
    }
    fail(value, Number);
}
function objectToNumber(value) {
    const unwrapped = unwrapObject(value);
    if (typeof unwrapped === 'number') {
        return notNaN(unwrapped);
    }
    else if (hasConverter(value, 'toString')) {
        return stringToNumber(String(value));
    }
    fail(value, Number);
}
function stringToBoolean(value) {
    const normal = value.trim().toLowerCase();
    if (normal in staticBoolean) {
        return staticBoolean[normal];
    }
    fail(value, Number);
}
function objectToBoolean(value) {
    const unwrapped = unwrapObject(value);
    if (typeof unwrapped === 'boolean') {
        return unwrapped;
    }
    else if (hasConverter(value, 'toString')) {
        return stringToBoolean(String(value));
    }
    fail(value, Boolean);
}
function objectToString(value) {
    if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
        throw new Error('Not supported');
    }
    try {
        if (value instanceof Error) {
            return value.message;
        }
        else if (value instanceof Date) {
            return value.toLocaleDateString();
        }
        const unwrapped = unwrapObject(value);
        if (isPrimitive(unwrapped)) {
            return toString(unwrapped);
        }
        else if (value instanceof Function) {
            return value.name ? value.name : 'function';
        }
        else if (value instanceof Array) {
            return value.map(toString).join(', ');
        }
        else if (hasConverter(value, 'toLocaleString')) {
            return value.toLocaleString();
        }
        else if (hasConverter(value, 'toString')) {
            return value.toString();
        }
        else if (value.constructor.name) {
            return firstToLower(value.constructor.name);
        }
        return String(value);
    }
    catch (ex) {
        return ex.message;
    }
}
function unwrapObject(value) {
    if (value instanceof Array && value.length === 1 && isPrimitive(value[0])) {
        return value[0];
    }
    if (value instanceof Function) {
        const returnValue = value.prototype ? new value() : value();
        if (isPrimitive(returnValue)) {
            return returnValue;
        }
    }
    if (hasConverter(value, 'valueOf')) {
        const valueOf = value.valueOf();
        if (isPrimitive(valueOf)) {
            return valueOf;
        }
    }
    if (('value' in value) && isPrimitive(value.value)) {
        return value.value;
    }
}
function isPrimitive(value) {
    return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
}
function notNaN(value) {
    if (typeof value !== 'number' || isNaN(value)) {
        fail(value, Number);
    }
    return value;
}
function isArrayLike(value) {
    const length = value.length;
    return typeof length === 'number'
        && !isNaN(length)
        && isFinite(length)
        && length >= 0
        && length === Math.round(length);
}
function firstToLower(value) {
    return value.slice(0, 1).toLocaleLowerCase() + value.slice(1);
}
function hasConverter(obj, property) {
    return obj[property] instanceof Function
        && obj[property] !== Object.prototype[property]
        && obj[property].length === 0;
}
function hasFactory(obj, property) {
    return obj[property] instanceof Function
        && obj[property].length === 1;
}
function verify(value, type, source) {
    try {
        checkType_1.checkType(value, type);
    }
    catch (ex) {
        throw new Error(source + 'returned invalid value: ' + ex.message);
    }
    return value;
}
function fail(value, type, ex) {
    throw new Error([
        'Can not convert ',
        checkType_1.getValueString(value),
        ' to ',
        checkType_1.getTypeName(type),
        ex ? ` (${ex.message})` : ''
    ].join(''));
}


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.equals = void 0;
const checkType_1 = __webpack_require__(6);
/**
 * Returns true if the two given values are equal.
 */
function equals(values, mode) {
    if (mode !== 'strict' && mode !== 'shallow' && mode !== 'auto' && !(mode instanceof Function)) {
        throw new Error('Invalid mode ' + checkType_1.getValueString(mode));
    }
    if (strictEqual(values)) {
        return true;
    }
    if (mode instanceof Function) {
        return booleanCheck('compare function', mode(values[0], values[1]));
    }
    if (mode === 'shallow') {
        return shallowEquals(values);
    }
    if (mode === 'auto') {
        return autoEquals(values);
    }
    return false;
}
exports.equals = equals;
function strictEqual(values) {
    if (typeof values[0] === 'number' && typeof values[1] === 'number') {
        return values[0] === values[1] || isNaN(values[0]) && isNaN(values[1]);
    }
    return values[0] === values[1];
}
function shallowEquals(values) {
    if (!isObjectPair(values)) {
        return false;
    }
    if (isArrayPair(values)) {
        return compareArrays(values);
    }
    return compareObjects(values);
}
function autoEquals(values) {
    if (!isObjectPair(values)) {
        return false;
    }
    if (isCustomEqualsPair(values)) {
        return booleanCheck('"equals" method', values[0].equals(values[1]));
    }
    if (isCustomValueOfPair(values)) {
        return compareValueOf(values);
    }
    if (isArrayPair(values) && values[0].constructor === Array) {
        return compareArrays(values);
    }
    if (values[0].constructor === Object) {
        return compareObjects(values);
    }
    return false;
}
function compareArrays(values) {
    return (values[0].length === values[1].length)
        && values[0].every((item, index) => item === values[1][index]);
}
function compareObjects(values) {
    const keysA = Reflect.ownKeys(values[0]).sort();
    const keysB = Reflect.ownKeys(values[1]).sort();
    return (keysA.length === keysB.length) && keysA.every((keyA, index) => {
        const keyB = keysB[index];
        return (keyA === keyB) && values[0][keyA] === values[1][keyB];
    });
}
function compareValueOf(values) {
    const valueOfA = values[0].valueOf();
    const valueOfB = values[1].valueOf();
    return valueOfA === valueOfB && typeof valueOfA !== 'object';
}
function isObjectPair(values) {
    if (!values[0] || !values[1]) {
        return false;
    }
    if (typeof values[0] !== 'object' || typeof values[1] !== 'object') {
        return false;
    }
    if (values[0].constructor !== values[1].constructor) {
        return false;
    }
    return true;
}
function isArrayPair(values) {
    return values[0] instanceof Array && values[1] instanceof Array;
}
function isCustomEqualsPair(values) {
    const [objectA, objectB] = values;
    return objectA.equals instanceof Function
        && objectA.equals === objectB.equals
        && objectA.equals.length === 1;
}
function isCustomValueOfPair([objectA, objectB]) {
    return objectA.valueOf !== Object.prototype.valueOf
        && objectA.valueOf instanceof Function
        && objectA.valueOf === objectB.valueOf
        && objectA.valueOf.length === 0;
}
function booleanCheck(fnDesc, value) {
    try {
        checkType_1.checkType(value, Boolean, true);
    }
    catch (ex) {
        throw new Error(`Invalid return value of ${fnDesc}: ${ex.message}`);
    }
    return value;
}


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.clearOneWayBindings = exports.getOneWayBindings = exports.applyJsxBindings = void 0;
__webpack_require__(3);
const CustomPropertyDescriptor_1 = __webpack_require__(4);
const utils_databinding_1 = __webpack_require__(2);
const placeholder = /\$\{[^}]+\}/g;
function applyJsxBindings(targetInstance, bindings, safety) {
    const oneWayBindings = [];
    for (const attribute in bindings) {
        try {
            oneWayBindings.push(createOneWayBindingDesc(targetInstance, attribute, asBinding(bindings[attribute]), safety));
        }
        catch (ex) {
            throwBindingFailedError({
                type: getBindingType(attribute),
                targetProperty: getTargetProperty(attribute),
                bindingString: bindings[attribute]
            }, ex);
        }
    }
    targetInstance[oneWayBindingsKey] = oneWayBindings;
    targetInstance.once({ resize: checkBindingsApplied });
}
exports.applyJsxBindings = applyJsxBindings;
function getOneWayBindings(instance) {
    return instance[oneWayBindingsKey];
}
exports.getOneWayBindings = getOneWayBindings;
function clearOneWayBindings(instance) {
    delete instance[oneWayBindingsKey];
}
exports.clearOneWayBindings = clearOneWayBindings;
function asBinding(value) {
    return {
        path: value && value.path ? value.path.toString() : (value || '').toString(),
        converter: value.converter
    };
}
function createOneWayBindingDesc(target, attribute, binding, unsafe) {
    const type = getBindingType(attribute);
    const targetProperty = getTargetProperty(attribute);
    const bindingString = binding.path;
    const pathString = extractPath(type, bindingString);
    utils_databinding_1.checkPathSyntax(pathString);
    if (pathString.startsWith('.') || pathString.startsWith('#')) {
        throw new Error('JSX binding path can currently not contain a selector.');
    }
    const path = pathString.split('.');
    utils_databinding_1.checkPropertyExists(target, targetProperty);
    if (CustomPropertyDescriptor_1.CustomPropertyDescriptor.isUnchecked(target, targetProperty)) {
        if (unsafe === 'error') {
            throw new Error(`Can not bind to property "${targetProperty}" without explicit type check.`);
        }
        console.warn(`Unsafe binding "${targetProperty}" -> "${bindingString}": `
            + `Property "${targetProperty}" has no type check.`);
    }
    const fallbackValue = target[targetProperty];
    const converter = type === 'template' ? compileTemplate(bindingString) : (binding.converter || (v => v));
    return {
        bindingString, target, targetProperty, path, fallbackValue, type, converter
    };
}
function extractPath(type, bindingString) {
    if (type === 'bind') {
        return bindingString;
    }
    const matches = bindingString.match(placeholder);
    if (!matches) {
        throw new Error(`Template "${bindingString}" does not contain a valid placeholder`);
    }
    if (matches.length > 1) {
        throw new Error(`Template "${bindingString}" contains too many placeholder`);
    }
    return matches[0].substring(2, matches[0].length - 1);
}
function checkBindingsApplied(ev) {
    if (getOneWayBindings(ev.target)) {
        throw new Error('Could not resolve one-way binding on CustomComponent: Not appended to a @component');
    }
}
function compileTemplate(template) {
    return value => template.replace(placeholder, value);
}
function getBindingType(attribute) {
    return attribute.split('-')[0];
}
function getTargetProperty(attribute) {
    return attribute.split('-')[1];
}
function throwBindingFailedError({ type, targetProperty, bindingString }, ex) {
    const isTemplate = type === 'template';
    throw new Error(`${isTemplate ? 'Template binding' : 'Binding'} "${targetProperty}" -> "${bindingString}" failed: ${ex.message}`);
}
const oneWayBindingsKey = Symbol();


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateProvider = exports.NO_ACTION = void 0;
const tabris_1 = __webpack_require__(0);
exports.NO_ACTION = Symbol();
class StateProvider {
    constructor(original) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.dispatch = () => {
            throw new Error('Not implemented');
        };
        const { getState, subscribe, dispatch } = original;
        this.getState = getState ? getState.bind(original) : this.getState;
        this.subscribe = subscribe ? subscribe.bind(original) : this.subscribe;
        this.dispatch = dispatch ? dispatch.bind(original) : this.dispatch;
    }
    static hook(options) {
        hookActions(options);
        hookState(options);
    }
    getState() {
        throw new Error('Not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(cb) {
        throw new Error('Not implemented');
    }
}
exports.StateProvider = StateProvider;
function hookState(options) {
    const { stateProvider, stateMapper, target } = options;
    if (stateMapper) {
        const widget = tabris_1.checkType(target, tabris_1.Widget, { name: 'target' });
        const update = () => applyRules(widget, stateMapper(stateProvider.getState()));
        update();
        stateProvider.subscribe(update);
    }
}
function hookActions(options) {
    const { stateProvider, target, actionMapper } = options;
    if (actionMapper) {
        const widget = tabris_1.checkType(target, tabris_1.Widget, { name: 'target' });
        applyRules(widget, getActionMapperFn(actionMapper)(stateProvider.dispatch));
    }
}
function getActionMapperFn(actionMapper) {
    if (actionMapper instanceof Function) {
        return actionMapper;
    }
    const actionCreators = Object.freeze(Object.assign({}, actionMapper));
    return dispatch => toActionDispatchers(dispatch, actionCreators);
}
function toActionDispatchers(dispatch, actionCreators, noApply) {
    const actions = {};
    for (const key in actionCreators) {
        if (key === 'apply') {
            if (noApply) {
                throw new Error('apply-in-apply');
            }
            actions.apply = {};
            for (const selector in actionCreators.apply) {
                actions.apply[selector]
                    = toActionDispatchers(dispatch, actionCreators.apply[selector], true);
            }
        }
        else {
            actions[key] = (...args) => dispatch(actionCreators[key].apply({}, args));
        }
        return actions;
    }
}
const applyRulesInternal = tabris_1.tabris.applyRules;
if (!applyRulesInternal) {
    throw new Error('Failed to access tabris internals. Outdated module version?');
}
function applyRules(widget, targetState) {
    tabris_1.checkType(targetState, Object, { nullable: false, name: 'target state' });
    const { apply: rules } = targetState, props = __rest(targetState, ["apply"]);
    tabris_1.checkType(rules, Object, { nullable: true, name: 'apply' });
    if (Object.keys(props).length) {
        const args = { rules: { ':host': props }, mode: 'strict', trigger: 'rules' };
        applyRulesInternal(args, widget, new tabris_1.WidgetCollection([widget]), true);
    }
    const selectors = Object.keys(rules || {});
    if (selectors.length) {
        const composite = tabris_1.checkType(widget, tabris_1.Composite, { nullable: true, name: 'apply' });
        const args = { rules, mode: 'strict', trigger: 'rules' };
        applyRulesInternal(args, composite, composite.find('*'), true);
    }
}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.property = void 0;
const CustomPropertyDescriptor_1 = __webpack_require__(4);
const utils_1 = __webpack_require__(1);
function property(...args) {
    return utils_1.applyDecorator('property', args, (proto, propertyName) => {
        CustomPropertyDescriptor_1.CustomPropertyDescriptor.get(proto, propertyName).addConfig({
            typeGuard: getTypeGuard(args[0]),
            type: getUserType(args[0]),
            convert: getConverter(args[0]),
            equals: getCompareMode(args[0]),
            default: getDefaultValue(args[0]),
            nullable: getNullable(args[0])
        });
    });
}
exports.property = property;
function getTypeGuard(arg) {
    if (arg instanceof Function) {
        return arg;
    }
    if (arg instanceof Object && arg.constructor === Object) {
        return arg.typeGuard || null;
    }
    return null;
}
function getUserType(arg) {
    if (arg instanceof Function) {
        return null;
    }
    if (arg instanceof Object && arg.constructor === Object) {
        return arg.type || null;
    }
    return null;
}
function getCompareMode(arg) {
    if (arg instanceof Function) {
        return null;
    }
    if (arg instanceof Object && arg.constructor === Object) {
        return arg.equals || null;
    }
    return null;
}
function getConverter(arg) {
    if (arg instanceof Function) {
        return null;
    }
    if (arg instanceof Object && arg.constructor === Object) {
        return arg.convert || null;
    }
    return null;
}
function getNullable(arg) {
    if (arg instanceof Function) {
        return null;
    }
    if (arg instanceof Object && arg.constructor === Object && 'nullable' in arg) {
        return arg.nullable;
    }
    return null;
}
function getDefaultValue(arg) {
    if (arg instanceof Function) {
        return undefined;
    }
    if (arg instanceof Object && arg.constructor === Object && 'default' in arg) {
        return arg.default;
    }
    return undefined;
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bind = void 0;
const Injector_1 = __webpack_require__(5);
const CustomPropertyDescriptor_1 = __webpack_require__(4);
const TwoWayBinding_1 = __webpack_require__(28);
const utils_1 = __webpack_require__(1);
const utils_databinding_1 = __webpack_require__(2);
function bind(...args) {
    return utils_1.applyDecorator('bind', args, (baseProto, baseProperty) => {
        const isShorthand = typeof args[0] === 'string';
        const pathString = isShorthand ? args[0] : args[0].path;
        const config = {
            componentProto: baseProto,
            componentProperty: baseProperty,
            targetPath: pathString ? utils_databinding_1.parseTargetPath(pathString) : null,
            all: parseAll(isShorthand ? null : args[0].all),
            typeGuard: isShorthand ? null : args[0].typeGuard,
            type: isShorthand ? null : args[0].type,
            equals: isShorthand ? null : args[0].equals || null,
            convert: isShorthand ? null : args[0].convert || null,
            nullable: isShorthand ? null : 'nullable' in args[0] ? args[0].nullable : null,
            default: isShorthand ? undefined : args[0].default
        };
        checkParameters(config);
        preCheckComponentProperty(config);
        configureComponentProperty(config);
        utils_databinding_1.postAppendHandlers(config.componentProto).push(component => TwoWayBinding_1.TwoWayBinding.create(component, config));
        scheduleIsComponentCheck(config);
    });
}
exports.bind = bind;
function configureComponentProperty(binding) {
    const { componentProto, componentProperty } = binding, config = __rest(binding, ["componentProto", "componentProperty"]);
    config.typeGuard = binding.all ? createBindAllTypeGuard(binding) : binding.typeGuard;
    CustomPropertyDescriptor_1.CustomPropertyDescriptor.get(componentProto, componentProperty).addConfig(config);
}
function checkParameters(binding) {
    if (binding.targetPath && binding.all) {
        throw new Error('@bind can not have "path" and "all" option simultaneously');
    }
    if (!binding.targetPath && !Object.keys(binding.all).length) {
        throw new Error('Missing binding path(s)');
    }
}
function preCheckComponentProperty(binding) {
    if (binding.targetPath) {
        // Will be checked on initialization
        return;
    }
    const { componentProto: baseProto, componentProperty: baseProperty } = binding;
    const type = binding.type || utils_1.getPropertyType(baseProto, baseProperty);
    if (utils_1.isPrimitiveType(type)) {
        throw new Error('Property type needs to extend Object');
    }
}
function parseAll(all) {
    if (!all) {
        return null;
    }
    const bindings = {};
    for (const key in all) {
        bindings[key] = utils_databinding_1.parseTargetPath(all[key]);
    }
    return bindings;
}
function createBindAllTypeGuard(binding) {
    const sourceProperties = Object.keys(binding.all);
    const baseProperty = binding.componentProperty;
    return (value) => {
        if (value) {
            if (!(value instanceof Object)) {
                throw new Error('Value needs to extend Object');
            }
            const className = binding.componentProto.constructor.name;
            for (const sourceProperty of sourceProperties) {
                utils_databinding_1.checkPropertyExists(value, sourceProperty, 'Object');
                if (CustomPropertyDescriptor_1.CustomPropertyDescriptor.isUnchecked(value, sourceProperty) && binding.all[sourceProperty][0] !== '>>') {
                    const strictMode = Injector_1.Injector.get(value, Injector_1.injector).jsxProcessor.unsafeBindings === 'error';
                    if (strictMode) {
                        throw new Error(`Object property "${sourceProperty}" requires an explicit type check.`);
                    }
                    const constructor = value.constructor === Object ? null : value.constructor;
                    const valueDesc = constructor ? constructor.name : 'the assigned object';
                    console.warn(`Unsafe two-way binding to ${className} property "${baseProperty}": `
                        + `Property "${sourceProperty}" of ${valueDesc} has no type check.`);
                }
            }
        }
        return binding.typeGuard ? binding.typeGuard(value) : true;
    };
}
function scheduleIsComponentCheck(binding) {
    setTimeout(() => {
        try {
            utils_databinding_1.checkIsComponent(binding.componentProto);
        }
        catch (ex) {
            const target = binding.all ? JSON.stringify(binding.all) : binding.targetPath.slice(1).join('.');
            console.error(`Binding "${binding.componentProperty}" <-> "${target}" failed to initialize: ` + ex.message);
        }
    });
}


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.List = exports.listObservers = void 0;
const tabris_1 = __webpack_require__(0);
const data = Symbol('data');
const observers = Symbol('observers');
const init = Symbol('init');
function listObservers(list) {
    return list[observers];
}
exports.listObservers = listObservers;
class List {
    constructor() {
        this[_a] = [];
        this[_b] = new tabris_1.Listeners(this, 'mutate');
        const param = arguments.length === 1 ? arguments[0] : false;
        if (arguments.length === 0) {
            this[data] = new Array();
        }
        else if (typeof param === 'number') {
            this[data] = new Array(param);
        }
        else if (isInitializer(param)) {
            this[data] = param[init];
        }
        else {
            this[data] = new Array(...arguments);
        }
        return new Proxy(this, traps);
    }
    static from(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    arrayLike, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    mapfn, thisArg) {
        const initData = Array.from.apply(Array, arguments);
        return new List({ [init]: initData });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static of(...items) {
        const initData = Array.of.apply(Array, arguments);
        return new List({ [init]: initData });
    }
    get length() {
        return this[data].length;
    }
    set length(value) {
        const oldLength = this[data].length;
        this[data].length = value;
        const newLength = this[data].length;
        this[observers].trigger({
            start: Math.min(oldLength, newLength),
            deleteCount: Math.max(oldLength - newLength, 0),
            items: new Array(Math.max(newLength - oldLength, 0))
        });
    }
    [(_a = data, _b = observers, Symbol.iterator)]() {
        return this[data][Symbol.iterator]();
    }
    entries() {
        return this[data].entries();
    }
    find(predicate, thisArg) {
        return this[data].find((value, index) => predicate.call(thisArg, value, index, this));
    }
    findIndex(predicate, thisArg) {
        return this[data].findIndex((value, index) => predicate.call(thisArg, value, index, this));
    }
    forEach(callbackfn, thisArg) {
        this[data].forEach((value, index) => callbackfn.call(thisArg, value, index, this));
    }
    indexOf(searchElement, fromIndex) {
        return this[data].indexOf(searchElement, fromIndex);
    }
    join(separator) {
        return this[data].join(separator);
    }
    keys() {
        return this[data].keys();
    }
    lastIndexOf(searchElement, fromIndex) {
        return this[data].lastIndexOf(searchElement, arguments.length > 1 ? fromIndex : this.length - 1);
    }
    pop() {
        const oldLength = this[data].length;
        const result = this[data].pop();
        this[observers].trigger({ start: oldLength - 1, deleteCount: 1, items: [] });
        return result;
    }
    push(...items) {
        const oldLength = this[data].length;
        const result = this[data].push.apply(this[data], items);
        if (items.length) {
            this[observers].trigger({ start: oldLength, deleteCount: 0, items });
        }
        return result;
    }
    shift() {
        const result = this[data].shift();
        this[observers].trigger({ start: 0, deleteCount: 1, items: [] });
        return result;
    }
    splice(start, deleteCount, ...items) {
        if (arguments.length === 0) {
            return [];
        }
        const oldLength = this[data].length;
        const startIndex = toInt(start);
        if (startIndex >= oldLength || ((arguments.length > 1) && (deleteCount == null) || (toInt(deleteCount) < 0))) {
            return [];
        }
        const finalStart = startIndex < 0 ? oldLength + startIndex : startIndex;
        const finalDeleteCount = Math.min(arguments.length < 2 ? (oldLength - finalStart) : toInt(deleteCount), oldLength - finalStart);
        const result = this[data].splice(finalStart, finalDeleteCount, ...items);
        this[observers].trigger({
            start: finalStart,
            deleteCount: finalDeleteCount,
            items
        });
        return result;
    }
    unshift(...items) {
        const result = this[data].unshift.apply(this[data], arguments);
        if (items.length) {
            this[observers].trigger({ start: 0, deleteCount: 0, items });
        }
        return result;
    }
    values() {
        return this[data].values();
    }
}
exports.List = List;
const traps = {
    ownKeys(target) {
        return Reflect.ownKeys(target[data]);
    },
    has(target, key) {
        if (isInt(key)) {
            return Reflect.has(target[data], key);
        }
        return Reflect.has(target, key);
    },
    get(target, key) {
        if (isInt(key)) {
            return Reflect.get(target[data], key);
        }
        return Reflect.get(target, key);
    },
    set(target, key, value) {
        if (isInt(key)) {
            const index = toInt(key);
            const length = target[data].length;
            target[data][index] = value;
            if (index >= length) {
                const items = new Array(index - length);
                items.push(value);
                target[observers].trigger({ start: length, deleteCount: 0, items });
            }
            else {
                target[observers].trigger({ start: index, deleteCount: 1, items: [value] });
            }
            return true;
        }
        return Reflect.set(target, key, value);
    },
    deleteProperty(target, key) {
        if (isInt(key)) {
            const index = toInt(key);
            delete target[data][index];
            target[observers].trigger({ start: index, deleteCount: 1, items: new Array(1) });
            return true;
        }
        return Reflect.deleteProperty(target, key);
    }
};
function isInitializer(value) {
    return value instanceof Object && value[init] instanceof Array;
}
const intRegEx = /^[0-9]+$/;
function isInt(value) {
    if (typeof value === 'string' && intRegEx.test(value)) {
        return true;
    }
    else if (typeof value === 'number') {
        return Math.round(value) === value;
    }
    return false;
}
function toInt(value) {
    // eslint-disable-next-line no-new-wrappers
    const num = typeof value === 'number' ? value : new Number(value).valueOf();
    if (isNaN(value)) {
        return 0;
    }
    return Math.round(num);
}


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ListLikeObserver = void 0;
const __1 = __webpack_require__(11);
class ListLikeObserver {
    constructor(_callback) {
        this._callback = _callback;
        this._source = null;
    }
    set source(value) {
        if (value === this._source) {
            return;
        }
        if (!(value instanceof __1.List) && !(value instanceof Array) && value !== null) {
            throw new Error(__1.getValueString(value) + ' is not a List or Array');
        }
        if (this._source instanceof __1.List) {
            __1.listObservers(this._source).removeListener(this._callback);
        }
        const oldValue = this._source;
        this._source = value;
        this._autoUpdate(oldValue);
        if (value instanceof __1.List) {
            __1.listObservers(value).addListener(this._callback);
        }
    }
    get source() {
        return this._source;
    }
    _autoUpdate(prevSource) {
        if (!(this._source instanceof Array && prevSource instanceof Array)) {
            return this._callback({
                start: 0,
                deleteCount: (prevSource || []).length,
                target: this._source || [],
                items: Array.from(this._source || [])
            });
        }
        const source = this._source;
        if (source.length === prevSource.length) {
            return source.forEach((value, index) => {
                if (value !== prevSource[index]) {
                    return this._callback({
                        start: index,
                        deleteCount: 1,
                        items: [source[index]],
                        target: source
                    });
                }
            });
        }
        if (source.length > prevSource.length) {
            const range = getDiff(source, prevSource);
            if (range) {
                return this._callback({
                    start: range[0],
                    deleteCount: 0,
                    items: source.slice(range[0], range[0] + range[1]),
                    target: source
                });
            }
        }
        if (source.length < prevSource.length) {
            const range = getDiff(prevSource, source);
            if (range) {
                return this._callback({
                    start: range[0],
                    deleteCount: range[1],
                    items: [],
                    target: source
                });
            }
        }
        this._callback({
            start: 0,
            deleteCount: prevSource.length,
            items: source,
            target: source
        });
    }
}
exports.ListLikeObserver = ListLikeObserver;
/**
 * Returns a single range that changed (insert or delete) between two arrays.
 * If this is not possible returns null instead. Assumes the item count has changed.
 */
function getDiff(listA, listB) {
    const start = getMatchLength([listB, 0], [listA, 0]);
    if (start === listB.length) {
        return [start, listA.length - start];
    }
    const nextMatch = listA.indexOf(listB[start], start);
    if (nextMatch < 0) {
        return null;
    }
    const length = nextMatch - start;
    const tail = getMatchLength([listB, start], [listA, start + length]);
    if (((start + length + tail) === listA.length) && ((start + tail) === listB.length)) {
        return [start, length];
    }
    return null;
}
/**
 * Returns the amount of items that are equal between the two
 * arrays starting from the given offsets.
 */
function getMatchLength([itemsA, offsetA], [itemsB, offsetB]) {
    let indexA = offsetA;
    let indexB = offsetB;
    while (indexA < itemsA.length && indexB < itemsB.length) {
        if (itemsA[indexA] === itemsB[indexB]) {
            indexA++;
            indexB++;
        }
        else {
            break;
        }
    }
    return indexA - offsetA;
}


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextCell = exports.Cell = void 0;
const tabris_1 = __webpack_require__(0);
const component_1 = __webpack_require__(9);
const event_1 = __webpack_require__(8);
const property_1 = __webpack_require__(16);
const ExtendedJSX_1 = __webpack_require__(7);
/* eslint-disable no-shadow */
const factory = Symbol('factory');
var internal;
(function (internal) {
    var Cell_1;
    let Cell = Cell_1 = class Cell extends tabris_1.Composite {
        constructor(properties) {
            super();
            this.selectable = false;
            this.item = null;
            this.itemIndex = -1;
            if (properties && ('item' in properties)) {
                throw new Error('item must not be initialized');
            }
            this.set(properties || {});
        }
        static factory(original) {
            if (!(original instanceof Cell_1)) {
                throw new Error('A cell factory can only be created from a Cell element');
            }
            if (!original[factory]) {
                let consumedOriginal = false;
                const jsxInfo = ExtendedJSX_1.getJsxInfo(original);
                if (!('processor' in jsxInfo)) {
                    throw new Error('Can not clone a non-JSX object');
                }
                original[factory] = () => {
                    if (!consumedOriginal) {
                        consumedOriginal = true;
                        return original;
                    }
                    return createFromTemplate(jsxInfo);
                };
            }
            return original[factory];
        }
        [JSX.jsxFactory](Type, attributes) {
            return tabris_1.Composite.prototype[JSX.jsxFactory].call(this, Type, attributes);
        }
    };
    __decorate([
        event_1.event,
        __metadata("design:type", tabris_1.ChangeListeners)
    ], Cell.prototype, "onItemChanged", void 0);
    __decorate([
        event_1.event,
        __metadata("design:type", tabris_1.ChangeListeners)
    ], Cell.prototype, "onItemIndexChanged", void 0);
    __decorate([
        property_1.property,
        __metadata("design:type", Boolean)
    ], Cell.prototype, "selectable", void 0);
    __decorate([
        property_1.property,
        __metadata("design:type", Object)
    ], Cell.prototype, "itemType", void 0);
    __decorate([
        property_1.property,
        __metadata("design:type", Function)
    ], Cell.prototype, "itemCheck", void 0);
    __decorate([
        property_1.property,
        __metadata("design:type", Object)
    ], Cell.prototype, "item", void 0);
    __decorate([
        property_1.property(num => num >= -1),
        __metadata("design:type", Number)
    ], Cell.prototype, "itemIndex", void 0);
    Cell = Cell_1 = __decorate([
        component_1.component,
        __metadata("design:paramtypes", [Object])
    ], Cell);
    internal.Cell = Cell;
    // Allow public "apply" method to break encapsulation
    // to better enable functional components
    Cell.prototype.apply = Cell.prototype._apply;
    class TextCell extends Cell {
        constructor() {
            super();
            const textView = new tabris_1.TextView().appendTo(this);
            textView.text = '' + this.item;
            this.onItemChanged(({ value }) => {
                textView.text = '' + value;
            });
        }
    }
    internal.TextCell = TextCell;
})(internal || (internal = {}));
exports.Cell = tabris_1.asFactory(internal.Cell);
exports.TextCell = tabris_1.asFactory(internal.TextCell);
function createFromTemplate(template) {
    if ('processor' in template) {
        const { processor: jsx, componentType, sfc, attributes, children } = template;
        const finalAttributes = Object.assign({}, attributes);
        if (children) {
            finalAttributes.children = children.map(createFromTemplate);
        }
        if (sfc) {
            return jsx.createFunctionalComponent(sfc, finalAttributes);
        }
        return jsx.createCustomComponent(componentType, finalAttributes);
    }
    if (template.source instanceof tabris_1.Widget) {
        throw new Error('Can not create copy of non JSX-element Widget');
    }
    return template.source;
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.unboundInject = exports.bindDecoratorInject = void 0;
__webpack_require__(3);
const Injector_1 = __webpack_require__(5);
const utils_1 = __webpack_require__(1);
const CustomPropertyDescriptor_1 = __webpack_require__(4);
function bindDecoratorInject(injector) {
    return unboundInject.bind(injector);
}
exports.bindDecoratorInject = bindDecoratorInject;
function unboundInject(...args) {
    return utils_1.applyDecorator('inject', args, (target, property, index) => {
        const param = typeof args[0] === 'string' ? args[0] : undefined;
        if (typeof index === 'number') {
            return setParameterInfo(target, index, param);
        }
        else if (!(target instanceof Function) && typeof property === 'string') {
            return injectProperty(target, property, param);
        }
        else {
            throw new Error('Invalid parameters');
        }
    });
}
exports.unboundInject = unboundInject;
function setParameterInfo(target, index, injectParam) {
    utils_1.getOwnParamInfo(target)[index] = {
        injectParam, type: utils_1.getParameterType(target, index), inject: true
    };
}
function injectProperty(proto, property, injectParam) {
    if (!utils_1.hasPropertyType(proto, property)) {
        throw new Error('Property type is undefined. You may have a broken import, circular module dependencies or an incorrect tsconfig.json configuration.');
    }
    const type = utils_1.getPropertyType(proto, property);
    if (type === Object) {
        throw new Error('Property type could not be inferred. Only classes and primitive types are supported.');
    }
    CustomPropertyDescriptor_1.CustomPropertyDescriptor.get(proto, property).addConfig({
        readonly: true,
        initializer(instance) {
            try {
                Injector_1.Injector.get(instance);
            }
            catch (_a) {
                throw new Error(`Can not inject "${property}" since class is not @injectable`);
            }
            return Injector_1.Injector.get(instance).resolve(type, injectParam || null);
        }
    });
    utils_1.getPropertyInfo(proto, property).inject = true;
}


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.injectableKey = exports.unboundInjectable = exports.bindDecoratorInjectable = void 0;
__webpack_require__(3);
const tabris_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(1);
function bindDecoratorInjectable(injector) {
    return unboundInjectable.bind(injector);
}
exports.bindDecoratorInjectable = bindDecoratorInjectable;
function unboundInjectable(...args) {
    return utils_1.applyDecorator('injectable', args, (targetType) => {
        Reflect.defineMetadata(exports.injectableKey, this, targetType);
        Reflect.defineMetadata(exports.injectableKey, this, targetType.prototype);
        const config = getInjectableConfig(args);
        const handler = (new DefaultInjectionHandler(targetType, config)).handleInjection;
        const priority = config.priority || 0;
        this.addHandler({ targetType, handler, priority });
        if (config.implements) {
            this.addHandler({ targetType: config.implements, handler, priority });
        }
    });
}
exports.unboundInjectable = unboundInjectable;
function getInjectableConfig(args) {
    if (!utils_1.areStaticClassDecoratorArgs(args)) {
        return args[0];
    }
    return {};
}
class DefaultInjectionHandler {
    constructor(type, config = {}) {
        this.type = type;
        this.config = config;
        this.handleInjection = (injection) => {
            if ('param' in this.config && injection.param !== this.config.param) {
                return null;
            }
            if (!this.config.shared) {
                return injection.injector.create(this.type);
            }
            const instance = this.instance;
            if (instance instanceof tabris_1.Widget && instance.isDisposed()) {
                this.instance = null;
            }
            if (!this.instance) {
                this.instance = injection.injector.create(this.type);
            }
            return this.instance;
        };
    }
}
exports.injectableKey = Symbol('injectable');


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.unboundInjectionHandler = exports.bindDecoratorInjectionHandler = void 0;
const utils_1 = __webpack_require__(1);
function bindDecoratorInjectionHandler(injector) {
    return unboundInjectionHandler.bind(injector);
}
exports.bindDecoratorInjectionHandler = bindDecoratorInjectionHandler;
function unboundInjectionHandler(...args) {
    return utils_1.applyDecorator('injectionHandler', args, (target, targetProperty) => {
        if (target instanceof Function) {
            const targetType = (args[0] instanceof Function ? args[0] : args[0].targetType);
            const priority = (args[0] instanceof Function ? 0 : args[0].priority) || 0;
            const handler = (injection) => target[targetProperty](injection);
            this.addHandler({ targetType, handler, priority });
        }
        else {
            throw new Error('Decorator must be applied to a method');
        }
    });
}
exports.unboundInjectionHandler = unboundInjectionHandler;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.unboundShared = exports.bindDecoratorShared = void 0;
function bindDecoratorShared(injector) {
    return unboundShared.bind(injector);
}
exports.bindDecoratorShared = bindDecoratorShared;
function unboundShared(type) {
    this.injectable({ shared: true })(type);
}
exports.unboundShared = unboundShared;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.initOneWayBinding = exports.processOneWayBindings = void 0;
__webpack_require__(3);
const applyJsxBindings_1 = __webpack_require__(14);
const subscribe_1 = __webpack_require__(10);
const utils_databinding_1 = __webpack_require__(2);
function processOneWayBindings(base, target) {
    const bindings = applyJsxBindings_1.getOneWayBindings(target);
    if (bindings) {
        for (const binding of bindings) {
            initOneWayBinding(base, binding);
        }
        applyJsxBindings_1.clearOneWayBindings(target);
    }
}
exports.processOneWayBindings = processOneWayBindings;
function initOneWayBinding(base, binding) {
    try {
        utils_databinding_1.checkPropertyExists(base, binding.path[0], base.constructor.name);
        const cancel = subscribe_1.subscribe(base, binding.path, rawValue => {
            try {
                applyValue(binding, evaluateBinding(binding, rawValue));
            }
            catch (ex) {
                throwBindingFailedError(binding, ex);
            }
        });
        base.on({ dispose: cancel });
    }
    catch (ex) {
        throwBindingFailedError(binding, ex);
    }
}
exports.initOneWayBinding = initOneWayBinding;
function evaluateBinding(binding, rawValue) {
    if (rawValue === undefined) {
        return binding.fallbackValue;
    }
    try {
        return binding.converter(rawValue);
    }
    catch (ex) {
        throw new Error('Converter exception: ' + ex.message);
    }
}
function applyValue(binding, value) {
    binding.target[binding.targetProperty] = value;
}
function throwBindingFailedError({ type, targetProperty, bindingString }, ex) {
    const isTemplate = type === 'template';
    throw new Error(`${isTemplate ? 'Template binding' : 'Binding'} "${targetProperty}" -> "${bindingString}" failed: ${ex.message}`);
}


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.connect = void 0;
__webpack_require__(3);
const tabris_1 = __webpack_require__(0);
const Injector_1 = __webpack_require__(5);
const StateProvider_1 = __webpack_require__(15);
const utils_1 = __webpack_require__(1);
const orgComponentKey = tabris_1.tabris.symbols.originalComponent;
const factoryProxyHandlerKey = tabris_1.tabris.symbols.proxyHandler;
const componentConfigKey = Symbol();
function connect(mapState, mapDispatchToProps) {
    return target => {
        try {
            const config = { stateMapper: mapState, actionMapper: mapDispatchToProps };
            const proxy = getProxy(target);
            updateConfig(proxy, config);
            addInjectorInjection(proxy, config);
            return proxy;
        }
        catch (error) {
            throw new Error(`Could not apply "connect" to ${target.name || 'component'}: ${error.message}`);
        }
    };
}
exports.connect = connect;
function getProxy(type) {
    if (Reflect.getOwnMetadata(componentConfigKey, type)) {
        return type;
    }
    if (type[orgComponentKey]) {
        return wrapFactoryProxy(type);
    }
    return createNewProxy(type);
}
function createNewProxy(type) {
    const proxy = new Proxy(type, {
        construct: (target, constructorArgs, protoTarget) => construct({ target: target, proxy, creationArgs: constructorArgs, context: protoTarget }),
        apply: (target, thisArg, callArgs) => apply({ target: target, proxy, creationArgs: callArgs, context: thisArg }),
        get: (target, property, receiver) => {
            if (receiver === proxy && property === orgComponentKey) {
                throw new Error('Must call "asFactory"/"component" before "connect"');
            }
            return Reflect.get(target, property, receiver);
        }
    });
    return proxy;
}
function wrapFactoryProxy(type) {
    const proxy = tabris_1.asFactory(type);
    const handler = proxy[factoryProxyHandlerKey];
    handler.construct = (target, constructorArgs, protoTarget) => construct({ target: target, proxy, creationArgs: constructorArgs, context: protoTarget });
    handler.get = (target, property, receiver) => {
        if (receiver === proxy && property === orgComponentKey) {
            throw new Error('Must call "asFactory"/"component" before "connect"');
        }
        return Reflect.get(target, property, receiver);
    };
    return proxy;
}
function updateConfig(target, config) {
    let current = Reflect.getOwnMetadata(componentConfigKey, target);
    if (!current) {
        current = {};
        Reflect.defineMetadata(componentConfigKey, current, target);
    }
    if (config.stateMapper) {
        if (current.stateMapper) {
            throw new Error('Component is already connected');
        }
        current.stateMapper = config.stateMapper;
    }
    if (config.actionMapper) {
        if (current.actionMapper) {
            throw new Error('Component is already connected');
        }
        current.actionMapper = config.actionMapper;
    }
}
function construct(options) {
    const connection = Reflect.getOwnMetadata(componentConfigKey, options.proxy);
    const target = Reflect.construct(options.target, options.creationArgs, options.context);
    return connectTarget(target, connection, options);
}
function apply(options) {
    const connection = Reflect.getOwnMetadata(componentConfigKey, options.proxy);
    const target = Reflect.apply(options.target, options.context, options.creationArgs);
    return connectTarget(target, connection, options);
}
function connectTarget(target, { stateMapper, actionMapper }, { creationArgs }) {
    if (target && (stateMapper || actionMapper)) {
        const stateProvider = getInjectable(StateProvider_1.StateProvider, target, creationArgs);
        StateProvider_1.StateProvider.hook({ stateProvider, target, stateMapper, actionMapper });
    }
    return target;
}
function addInjectorInjection(proxy, config) {
    if (proxy.prototype && config.stateMapper || config.actionMapper) {
        pushParameterInfo(proxy, { type: Injector_1.Injector, inject: true });
    }
}
function getInjectable(type, target, args) {
    const injector = args.find(arg => arg instanceof Injector_1.Injector) || Injector_1.Injector.get(target, Injector_1.injector);
    return injector.resolve(type);
}
function pushParameterInfo(target, info) {
    const paramInfo = utils_1.getOwnParamInfo(target);
    if (paramInfo.find(entry => entry
        && entry.type === info.type
        && entry.inject === info.inject
        && entry.injectParam === info.injectParam)) {
        return;
    }
    paramInfo[Math.max(1, paramInfo.length, target.length)] = info;
}


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.prop = void 0;
const CustomPropertyDescriptor_1 = __webpack_require__(4);
const utils_1 = __webpack_require__(1);
function prop(...args) {
    return utils_1.applyDecorator('prop', args, (proto, propertyName) => {
        CustomPropertyDescriptor_1.CustomPropertyDescriptor.get(proto, propertyName).addConfig({
            typeGuard: getTypeGuard(args[0]),
            type: getUserType(args[0]),
            convert: getConverter(args[0]),
            equals: getCompareMode(args[0]),
            default: getDefaultValue(args[0]),
            nullable: getNullable(args[0])
        });
    });
}
exports.prop = prop;
function getTypeGuard(arg) {
    if (arg instanceof Function) {
        return null;
    }
    if (arg instanceof Object && arg.constructor === Object) {
        return arg.typeGuard || null;
    }
    return null;
}
function getUserType(arg) {
    if (arg instanceof Function) {
        return arg;
    }
    if (arg instanceof Object && arg.constructor === Object) {
        return arg.type || null;
    }
    return null;
}
function getCompareMode(arg) {
    if (arg instanceof Function) {
        return 'auto';
    }
    if (arg instanceof Object && arg.constructor === Object) {
        return arg.equals || 'auto';
    }
    return 'auto';
}
function getConverter(arg) {
    if (arg instanceof Function) {
        return 'auto';
    }
    if (arg instanceof Object && arg.constructor === Object) {
        return arg.convert || 'auto';
    }
    return 'auto';
}
function getNullable(arg) {
    if (arg instanceof Function) {
        return false;
    }
    if (arg instanceof Object && arg.constructor === Object) {
        return !!arg.nullable;
    }
    return false;
}
function getDefaultValue(arg) {
    if (arg instanceof Function) {
        return CustomPropertyDescriptor_1.autoDefault;
    }
    if (arg instanceof Object && arg.constructor === Object && 'default' in arg) {
        return arg.default;
    }
    return CustomPropertyDescriptor_1.autoDefault;
}


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TwoWayBinding = void 0;
const CustomPropertyDescriptor_1 = __webpack_require__(4);
const ExtendedJSX_1 = __webpack_require__(7);
const subscribe_1 = __webpack_require__(10);
const utils_databinding_1 = __webpack_require__(2);
const Injector_1 = __webpack_require__(5);
class TwoWayBinding {
    constructor(component, localPath, targetPath) {
        this.component = component;
        this.localPath = localPath;
        this.targetPath = targetPath;
        this.suspended = false;
        if (this.localPath.length > 2) {
            throw new Error('Invalid number of path segments');
        }
        this.target = utils_databinding_1.getTarget(this.component, this.targetPath[1]);
        this.direction = this.targetPath[0];
        this.targetProperty = this.targetPath[2];
        this.fallback = this.target[this.targetProperty];
        if (!this.direction || this.direction === '>>') {
            this.checkPropertySafety(this.target, this.targetProperty, 'Right');
        }
        if (!this.direction || this.direction === '<<') {
            this.checkPropertySafety(this.component, this.localPath[0], 'Left');
        }
        this.init();
    }
    static create(component, config) {
        if (config.all) {
            for (const sourceProperty in config.all) {
                const localPath = [config.componentProperty, sourceProperty];
                const targetPath = config.all[sourceProperty];
                try {
                    new TwoWayBinding(component, localPath, targetPath);
                }
                catch (ex) {
                    throw new Error(`Binding ${bindingToString(localPath, targetPath)} failed to initialize: ` + ex.message);
                }
            }
        }
        else {
            const localPath = [config.componentProperty];
            try {
                new TwoWayBinding(component, localPath, config.targetPath);
            }
            catch (ex) {
                throw new Error(`Binding ${bindingToString(localPath, config.targetPath)} failed to initialize: ` + ex.message);
            }
        }
    }
    toString() {
        return bindingToString(this.localPath, this.targetPath);
    }
    init() {
        if (!this.direction || this.direction === '>>') {
            this.cancelLocal = this.subscribeToLocalValue();
        }
        else if (this.direction === '<<' && this.localPath.length === 2) {
            this.cancelLocal = this.subscribe(this.component, [this.localPath[0]], () => {
                this.setSourceProperty(this.target[this.targetProperty]);
            });
        }
        if (!this.direction || this.direction === '<<') {
            this.cancelTarget = this.subscribeToTargetValue();
        }
        this.component.on({ dispose: () => this.dispose() });
    }
    dispose() {
        if (this.cancelLocal) {
            this.cancelLocal();
        }
        if (this.cancelTarget) {
            this.cancelTarget();
        }
    }
    subscribeToLocalValue() {
        return this.subscribe(this.component, this.localPath, rawValue => {
            const finalValue = rawValue !== undefined ? rawValue : this.fallback;
            this.tryTo('update right hand property', () => this.setTargetProperty(finalValue));
            this.tryTo('sync back value of right hand property', () => this.setSourceProperty(finalValue));
        });
    }
    subscribeToTargetValue() {
        return this.subscribe(this.target, [this.targetProperty], rawValue => {
            if (this.hasValidSource()) {
                const finalValue = rawValue !== undefined ? rawValue : this.fallback;
                this.tryTo('update left hand property', () => this.setSourceProperty(finalValue));
                if (this.direction !== '<<') {
                    this.tryTo('sync back value of left hand property', () => {
                        if (this.hasValidSource() && this.getSourceValue() !== finalValue) {
                            this.setTargetProperty(this.getSourceValue());
                        }
                    });
                }
            }
        });
    }
    subscribe(root, path, cb) {
        return subscribe_1.subscribe(root, path, value => {
            if (this.suspended) {
                return;
            }
            this.suspended = true;
            cb(value);
            this.suspended = false;
        });
    }
    setSourceProperty(finalValue) {
        if (this.localPath.length === 2 && this.component[this.localPath[0]]) {
            this.component[this.localPath[0]][this.localPath[1]] = finalValue;
        }
        else if (this.localPath.length === 1) {
            this.component[this.localPath[0]] = finalValue;
        }
    }
    getSourceValue() {
        if (this.localPath.length === 2 && this.component[this.localPath[0]]) {
            return this.component[this.localPath[0]][this.localPath[1]];
        }
        else if (this.localPath.length === 1) {
            return this.component[this.localPath[0]];
        }
        throw new Error('No valid source');
    }
    hasValidSource() {
        return this.localPath.length === 1 || this.component[this.localPath[0]] instanceof Object;
    }
    setTargetProperty(value) {
        this.target[this.targetProperty] = value;
    }
    checkPropertySafety(target, property, dir) {
        utils_databinding_1.checkPropertyExists(target, property);
        if (CustomPropertyDescriptor_1.CustomPropertyDescriptor.isUnchecked(target, property)) {
            if (isInStrictMode(target)) {
                throw new Error(`${dir} hand property "${property}" requires an explicit type check.`);
            }
            console.warn(`Unsafe two-way binding ${this}: ${dir} hand property "${property}" has no type check.`);
        }
    }
    tryTo(taskDesc, cb) {
        try {
            cb();
        }
        catch (ex) {
            throw new Error(`Binding ${this} failed to ${taskDesc}: ${ex.message}`);
        }
    }
}
exports.TwoWayBinding = TwoWayBinding;
function isInStrictMode(widget) {
    const jsxInfo = ExtendedJSX_1.getJsxInfo(widget);
    const processor = 'processor' in jsxInfo ? jsxInfo.processor : Injector_1.injector.jsxProcessor;
    return processor.unsafeBindings === 'error';
}
function bindingToString(localPath, targetPath) {
    try {
        return `"${localPath.join('.')}" <-> "${targetPath[1]}.${targetPath[2]}"`;
    }
    catch (ex) {
        return '[' + ex.message + ']';
    }
}


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.bindAll = void 0;
const bind_1 = __webpack_require__(17);
/**
 * A decorator for instance properties of classes extending `Composite`, i.e. a custom component.
 * It creates a two-way binding between properties of a model (e.g. an object using `@property`)
 * and children (descendants) of the component. Example:
 *
 *  ```ts
 * @bindAll({
 *  modelPropA: '#childId1.text'
 *  modelPropB: '#childId2.selection'
 * })
 * myProp: MyModel;
 *
 * ```
 * *Notes:*
 * * *`@bindAll` behaves like `@property` in most regards.*
 * * *`@bindAll(bindings)` is a shorthand for `@bind({all: bindings})`. The latter
 * also supports the `typeGuard` and `type` options.*
 * * *In addition to id selectors, type selectors and `:host` are also supported.* *
 * * *Use`@bind(path)` or `@bind({path: path})` to create bindings to the property itself.*
 */
function bindAll(bindings) {
    return bind_1.bind({ all: bindings });
}
exports.bindAll = bindAll;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getById = void 0;
__webpack_require__(3);
const tabris_1 = __webpack_require__(0);
const checkType_1 = __webpack_require__(6);
const utils_1 = __webpack_require__(1);
const utils_databinding_1 = __webpack_require__(2);
function getById(...args) {
    return utils_1.applyDecorator('getById', args, (widgetProto, property) => {
        const check = args[0] instanceof Function ? args[0] : null;
        const type = utils_1.getPropertyType(widgetProto, property);
        if (type !== Object
            && !(type.prototype instanceof tabris_1.Widget)
            && type.prototype !== tabris_1.Widget.prototype) {
            throw new Error(`Type "${type.name}" is not a widget.`);
        }
        utils_databinding_1.postAppendHandlers(widgetProto).push((widget) => {
            try {
                utils_databinding_1.getPropertyStore(widget).set(property, getByIdImpl(widget, property, check));
            }
            catch (ex) {
                throwPropertyResolveError('getById', property, ex.message);
            }
        });
        utils_1.defineGetter(widgetProto, property, function () {
            try {
                utils_databinding_1.checkIsComponent(this);
                utils_databinding_1.checkAppended(this);
            }
            catch (ex) {
                throwPropertyResolveError('getById', property, ex.message);
            }
            return utils_databinding_1.getPropertyStore(this).get(property);
        });
        // class decorators are applied after property decorators, therefore a timeout is needed
        setTimeout(() => {
            try {
                utils_databinding_1.checkIsComponent(widgetProto);
            }
            catch (ex) {
                console.error(getErrorMessage('getById', property, ex.message));
            }
        });
    });
}
exports.getById = getById;
function getByIdImpl(widgetInstance, property, typeGuard) {
    const results = widgetInstance._find('#' + property);
    if (results.length === 0) {
        throw new Error(`No widget with id "${property}" appended.`);
    }
    if (results.length > 1) {
        throw new Error(`More than one widget with id "${property}" appended.`);
    }
    if (typeGuard) {
        if (!typeGuard(results[0])) {
            throw new Error('Type guard rejected widget');
        }
    }
    else {
        checkType_1.checkType(results[0], utils_1.getPropertyType(widgetInstance, property));
    }
    return results[0];
}
function throwPropertyResolveError(decorator, property, message) {
    throw new Error(getErrorMessage(decorator, property, message));
}
function getErrorMessage(decorator, property, message) {
    return `Decorator "${decorator}" could not resolve property "${property}": ${message}`;
}


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemPicker = exports.ItemPickerSelectEvent = void 0;
const tabris_1 = __webpack_require__(0);
const checkType_1 = __webpack_require__(6);
const List_1 = __webpack_require__(18);
const event_1 = __webpack_require__(8);
const ListLikeObserver_1 = __webpack_require__(19);
const subscribe_1 = __webpack_require__(10);
const utils_databinding_1 = __webpack_require__(2);
/* eslint-disable no-shadow */
// Usage of 'any' for backwards compatibility with 3.4.0 where the Target parameter
// did not exist yet. The change was necessary to work around circular type references
// issues with TypeScript 3.8.
class ItemPickerSelectEvent extends tabris_1.EventObject {
    constructor(item, itemIndex, itemText) {
        super();
        this.item = item;
        this.itemIndex = itemIndex;
        this.itemText = itemText;
    }
}
exports.ItemPickerSelectEvent = ItemPickerSelectEvent;
var internal;
(function (internal) {
    class ItemPicker extends tabris_1.Picker {
        constructor(_a = {}) {
            var { items, textSource } = _a, properties = __rest(_a, ["items", "textSource"]);
            super();
            this._inRefresh = false;
            this._handleListMutation = (ev) => {
                this.itemCount = ev.target.length;
                this._computeTexts();
                if (!ev.target || !ev.target.length) {
                    this.selectionIndex = -1;
                }
                else if (ev.items.length === ev.target.length) {
                    this.selectionIndex = 0;
                }
                else if (ev.deleteCount === ev.items.length) {
                    this.onSelectionChanged.trigger({ value: this.selection });
                }
                else if (ev.start <= this.selectionIndex) {
                    this.selectionIndex = -1;
                }
            };
            this._handleSelectionIndexChanged = () => {
                if (!this._inRefresh) {
                    this.onSelectionChanged.trigger({ value: this.selection });
                }
            };
            this._handleSelect = ({ index }) => {
                this.onItemSelect.trigger(new ItemPickerSelectEvent(this.items[index], index, this.itemText(index)));
            };
            this._observer = new ListLikeObserver_1.ListLikeObserver(this._handleListMutation);
            this.textSource = textSource || null;
            this.items = items || null;
            this.set(properties);
            this.onSelect(this._handleSelect);
            this.onSelectionIndexChanged(this._handleSelectionIndexChanged);
        }
        set items(value) {
            if (value === this._observer.source) {
                return;
            }
            this._observer.source = value;
            this.onItemsChanged.trigger({ value });
        }
        get items() {
            return this._observer.source;
        }
        set selection(value) {
            this.selectionIndex = (this.items || []).indexOf(value);
        }
        get selection() {
            return (this.items || [])[this.selectionIndex] || null;
        }
        set textSource(value) {
            if (value === this._textSource) {
                return;
            }
            let binding = null;
            if (value instanceof Object) {
                const { path, converter } = value;
                binding = { path, converter: converter || String };
            }
            else if (value && typeof value === 'string') {
                binding = { path: value, converter: String };
            }
            if (binding) {
                utils_databinding_1.checkPathSyntax(binding.path);
                if (binding.path.startsWith('.') || binding.path.startsWith('#')) {
                    throw new Error('textSource path starts with invalid character');
                }
            }
            this._textSource = binding;
            this.onTextSourceChanged.trigger({ value });
            this._computeTexts();
        }
        get textSource() {
            return this._textSource;
        }
        _computeTexts() {
            this._unbindItems();
            if (!this.items) {
                this._texts = null;
            }
            else if (this._textSource) {
                this._texts = this._bindItems(this._textSource);
            }
            else {
                this._texts = Array.from(this.items, String);
            }
            this._refresh();
        }
        _bindItems(binding) {
            let initial = true;
            const path = binding.path.split('.');
            const texts = [];
            this._unsubsribers = Array.from(this.items).map((item, index) => {
                try {
                    return subscribe_1.subscribe(item, path, value => {
                        try {
                            const textValue = value != null ? binding.converter(value) : value;
                            checkType_1.checkType(textValue, String, true);
                            texts[index] = textValue;
                        }
                        catch (ex) {
                            console.warn(`ItemPicker can not compute value of ${binding.path} for item ${index}: ${ex.message}`);
                            texts[index] = 'undefined';
                        }
                        if (!initial) {
                            this._refresh();
                        }
                    });
                }
                catch (ex) {
                    console.warn(`ItemPicker can not compute value of ${binding.path} for item ${index}: ${ex.message}`);
                    texts[index] = 'undefined';
                    return () => undefined;
                }
            });
            initial = false;
            return texts;
        }
        _unbindItems() {
            (this._unsubsribers || []).forEach(unsubscribe => unsubscribe());
            this._unsubsribers = null;
        }
        _refresh() {
            if (this._inRefresh) {
                return;
            }
            this._inRefresh = true;
            this.itemText = index => this._texts[index];
            const selectionIndex = this.selectionIndex;
            this.selectionIndex = -1;
            this.selectionIndex = selectionIndex;
            this._inRefresh = false;
        }
        _reorderProperties(properties) {
            const reOrdrered = properties.concat();
            const selectionPos = reOrdrered.indexOf('selection');
            if (selectionPos !== -1) {
                reOrdrered.splice(selectionPos, 1);
                reOrdrered.push('selection');
            }
            const selectionIndexPos = reOrdrered.indexOf('selectionIndex');
            if (selectionIndexPos !== -1) {
                reOrdrered.splice(selectionIndexPos, 1);
                reOrdrered.push('selectionIndex');
            }
            return super._reorderProperties(reOrdrered);
        }
        // eslint-disable-next-line @typescript-eslint/member-ordering
        [JSX.jsxFactory](Type, attributes) {
            const { children, selection, selectionIndex } = attributes, pureAttributes = __rest(attributes, ["children", "selection", "selectionIndex"]);
            const content = children ? children[0] : null;
            const result = tabris_1.Picker.prototype[JSX.jsxFactory].call(this, Type, pureAttributes);
            if (content instanceof Array || content instanceof List_1.List) {
                result.items = content;
            }
            else if (typeof content === 'string') {
                result.items = List_1.List.from(content.split(',').map(str => str.trim()));
            }
            if (selection !== undefined) {
                result.selection = selection;
            }
            if (selectionIndex !== undefined) {
                result.selectionIndex = selectionIndex;
            }
            return result;
        }
    }
    __decorate([
        event_1.event,
        __metadata("design:type", tabris_1.Listeners)
    ], ItemPicker.prototype, "onItemSelect", void 0);
    __decorate([
        event_1.event,
        __metadata("design:type", tabris_1.Listeners)
    ], ItemPicker.prototype, "onItemsChanged", void 0);
    __decorate([
        event_1.event,
        __metadata("design:type", tabris_1.Listeners)
    ], ItemPicker.prototype, "onSelectionChanged", void 0);
    __decorate([
        event_1.event,
        __metadata("design:type", tabris_1.ChangeListeners)
    ], ItemPicker.prototype, "onTextSourceChanged", void 0);
    internal.ItemPicker = ItemPicker;
})(internal || (internal = {}));
exports.ItemPicker = tabris_1.asFactory(internal.ItemPicker);


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.to = void 0;
/**
 * Allows assigning a converter function to a one way binding:
 *
 *    <textView
 *       bind-text={to('person.dob', v => v.toLocaleString())} />
 *
 * This is the same as:
 *
 *    <textView
 *       bind-text={{path: 'person.dob', converter: v => v.toLocaleString())} />
 *
 *  Can also be used to create reuseable shorthands:
 *
 *     const toLocaleString
 *       = (path: string) => to(path, v => v.toLocaleString());
 *
 *     <textView bind-text={toLocaleString('person.dob')} />
 */
function to(path, converter) {
    return { path, converter };
}
exports.to = to;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListView = exports.ListViewSelectEvent = exports.ItemAction = void 0;
const tabris_1 = __webpack_require__(0);
const Cell_1 = __webpack_require__(20);
const component_1 = __webpack_require__(9);
const event_1 = __webpack_require__(8);
const ListLikeObserver_1 = __webpack_require__(19);
var ItemAction;
(function (ItemAction) {
    ItemAction[ItemAction["Primary"] = 1] = "Primary";
    ItemAction[ItemAction["Secondary"] = 2] = "Secondary";
    ItemAction[ItemAction["Toggle"] = 3] = "Toggle";
    ItemAction[ItemAction["Dismiss"] = 4] = "Dismiss";
})(ItemAction = exports.ItemAction || (exports.ItemAction = {}));
// Usage of 'any' for backwards compatibility with 3.4.0 where the Target parameter
// did not exist yet. The change was necessary to work around circular type references
// issues with TypeScript 3.8.
class ListViewSelectEvent extends tabris_1.EventObject {
    constructor(item, itemIndex, originalEvent, action) {
        super();
        this.item = item;
        this.itemIndex = itemIndex;
        this.originalEvent = originalEvent;
        this.action = action;
    }
}
exports.ListViewSelectEvent = ListViewSelectEvent;
var internal;
(function (internal) {
    var ListView_1;
    let ListView = ListView_1 = class ListView extends tabris_1.CollectionView {
        constructor(properties = {}) {
            super();
            this._handleMutation = ({ start, deleteCount, items, target }) => {
                if (start === 0 && target.length === items.length) {
                    return this.load(items.length);
                }
                const refreshCount = Math.min(items.length, deleteCount);
                for (let i = start; i < start + refreshCount; i++) {
                    this.refresh(i);
                }
                if (deleteCount > items.length) {
                    this.remove(start + refreshCount, deleteCount - refreshCount);
                }
                else if (items.length > deleteCount) {
                    this.insert(start + refreshCount, items.length - refreshCount);
                }
                this._children().forEach(cell => {
                    const newIndex = this.itemIndex(cell);
                    if (newIndex >= 0) {
                        cell.itemIndex = newIndex;
                    }
                });
            };
            this._observer = new ListLikeObserver_1.ListLikeObserver(this._handleMutation);
            this
                .set({ createCell: defaultCreateCell, updateCell } /* tabris declarations bug */)
                .set(properties);
        }
        static selectPrimary(ev) {
            ListView_1.select(ev, ItemAction.Primary);
        }
        static selectSecondary(ev) {
            ListView_1.select(ev, ItemAction.Secondary);
        }
        static selectToggle(ev) {
            ListView_1.select(ev, ItemAction.Toggle);
        }
        static selectDismiss(ev) {
            ListView_1.select(ev, ItemAction.Dismiss);
        }
        static select(ev, action = 0) {
            const listView = ev.target.parent(ListView_1);
            const itemIndex = listView.itemIndex(ev.target);
            listView.onSelect.trigger(new ListViewSelectEvent(listView.items[itemIndex], itemIndex, ev, action));
        }
        set items(value) {
            if (value === this._observer.source) {
                return;
            }
            this._observer.source = value;
            this.onItemsChanged.trigger({ value });
        }
        get items() {
            return this._observer.source;
        }
        // eslint-disable-next-line @typescript-eslint/member-ordering
        [JSX.jsxFactory](Type, attributes) {
            const { children } = attributes, pureAttributes = __rest(attributes, ["children"]);
            const result = tabris_1.CollectionView.prototype[JSX.jsxFactory].call(this, Type, pureAttributes);
            if (children instanceof Array) {
                const factories = children.map((child) => ({
                    itemType: child.itemType,
                    itemCheck: child.itemCheck,
                    itemHeight: child.height,
                    create: Cell_1.Cell.factory(child)
                }));
                result.cellType = getCellTypeCallback(result, factories);
                result.cellHeight = getCellHeightCallback(result, factories);
                result.createCell = getCreateCellCallback(factories);
            }
            return result;
        }
    };
    __decorate([
        event_1.event,
        __metadata("design:type", tabris_1.ChangeListeners)
    ], ListView.prototype, "onItemsChanged", void 0);
    __decorate([
        event_1.event,
        __metadata("design:type", tabris_1.Listeners)
    ], ListView.prototype, "onSelect", void 0);
    ListView = ListView_1 = __decorate([
        component_1.component,
        __metadata("design:paramtypes", [Object])
    ], ListView);
    internal.ListView = ListView;
})(internal || (internal = {}));
exports.ListView = tabris_1.asFactory(internal.ListView);
function getCellTypeCallback(listView, factories) {
    const cellFactoryIndex = (itemIndex) => {
        const item = listView.items[itemIndex];
        const factoryIndex = factories.findIndex(entry => factorySupportsItem(entry, item));
        if (factoryIndex < 0) {
            throw new Error('No cell factory found for item ' + itemIndex);
        }
        return factoryIndex;
    };
    return (itemIndex) => cellFactoryIndex(itemIndex) + '';
}
function getCellHeightCallback(listView, factories) {
    const fallback = typeof listView.cellHeight === 'number' ? listView.cellHeight : 'auto';
    return (itemIndex) => {
        const factory = factories.find(entry => factorySupportsItem(entry, listView.items[itemIndex]));
        if (!factory) {
            throw new Error('No cell factory found for item ' + itemIndex);
        }
        return factory.itemHeight === 'auto' ? fallback : factory.itemHeight;
    };
}
function factorySupportsItem(factory, item) {
    if (factory.itemType instanceof Function && !(item instanceof factory.itemType)) {
        return false;
    }
    if (typeof factory.itemType === 'string' && typeof item !== factory.itemType) {
        return false;
    }
    if (factory.itemCheck instanceof Function && !factory.itemCheck(item)) {
        return false;
    }
    return true;
}
function getCreateCellCallback(factories) {
    return (type) => {
        const factoryIndex = parseInt(type, 10);
        if (isNaN(factoryIndex)) {
            throw new Error('Invalid cell factory index ' + factoryIndex);
        }
        const result = factories[factoryIndex].create();
        if (result.selectable) {
            result.highlightOnTouch = true;
            result.onTap(exports.ListView.select);
        }
        return result;
    };
}
function defaultCreateCell() {
    return new Cell_1.TextCell();
}
function updateCell(cell, index) {
    cell.item = this.items[index];
    cell.itemIndex = index;
}


/***/ })
/******/ ]);